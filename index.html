<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,">
  <title>mccivmap</title>
  <style>
    body { margin: 0; background: #000; color: #fff; font: 14px system-ui; }
    #main-canvas { position: fixed; width: 100%; height: 100%; touch-action: none; }
    #hud-x,#hud-z { display: none; background: #0008; position: fixed; top: 12px; padding: .3rem .6rem; border-radius: .4rem; pointer-events: none; font-variant-numeric: tabular-nums; }
    #hud-x { right: 50%; border-top-right-radius: 0; border-bottom-right-radius: 0; text-align: right; }
    #hud-z { left: 50%; border-top-left-radius: 0; border-bottom-left-radius: 0; text-align: left; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 9999; }
    @font-face { font-family: 'MinecraftItalic'; src: url('/fonts/MinecraftItalic-R8Mo.otf') format('opentype'); }
  </style>
</head>
<body>
  <div id="loading">loading map...</div>
  <canvas id="main-canvas"></canvas>
  <span id="hud-x">0</span>
  <span id="hud-z">0</span>
  <div id="textbox" style="position:fixed;top:0;left:0;padding:6px;font:16px monospace;max-width:90vw;word-wrap:break-word;">
    by @crazycraftix<br>
    TAB to show LABELS<br>
    NUMBERS switch MAPS
  </div>
  <script>
    'use strict';

    // ========== UTIL ==========
    function* boundedDiamondPattern(centerX, centerY, minX, minY, maxX, maxY) {
      yield { x: centerX, y: centerY };

      let yieldCount = 1;
      const totalYields = (maxX - minX + 1) * (maxY - minY + 1);

      for(let radius = 0; yieldCount < totalYields; radius++) {
        for(let i = 0; i < radius; i++) {
          const tileCoords = [
            { dx:  i,          dy:  radius - i },
            { dx: -i,          dy:  i - radius },
            { dx:  radius - i, dy: -i          },
            { dx:  i - radius, dy:  i          },
          ];
          for (const { dx, dy } of tileCoords) {
            const tileX = centerX + dx;
            if (tileX < minX || tileX > maxX) continue;
            const tileY = centerY + dy;
            if (tileY < minY || tileY > maxY) continue;
            yieldCount++;
            yield { x: tileX, y: tileY };
          }
        }
      }
    }



    // ========== CAMERA ==========
    class Camera {
      #x = 0;
      #y = 0;
      #scale = 1;
      #changeCallbacks = [];

      get x()     { return this.#x;     }
      get y()     { return this.#y;     }
      get scale() { return this.#scale; }

      set x(v)     { this.#x = v;     this.#changed(); }
      set y(v)     { this.#y = v;     this.#changed(); }
      set scale(v) { this.#scale = v; this.#changed(); }

      constructor() {
        Object.seal(this);
      }

      worldToScreen(x, y, screenWidth, screenHeight) {
        return {
          x: (x - this.#x) * this.#scale + screenWidth /2,
          y: (y - this.#y) * this.#scale + screenHeight/2,
        };
      }

      screenToWorld(x, y, screenWidth, screenHeight) {
        return {
          x: (x - screenWidth /2) / this.#scale + this.#x,
          y: (y - screenHeight/2) / this.#scale + this.#y,
        };
      }

      worldToScreenDistance(value) { return value * this.#scale; }
      screenToWorldDistance(value) { return value / this.#scale; }

      apply(ctx, scaleQuantizationSize = null) {
        const quantizedScale = (scaleQuantizationSize === null) ? this.#scale : Math.round(this.#scale * scaleQuantizationSize) / scaleQuantizationSize;

        // quantize translation to reduce flimmer
        const quantizedTranslation = {
          x: Math.round(ctx.canvas.width /2 - quantizedScale * this.#x),
          y: Math.round(ctx.canvas.height/2 - quantizedScale * this.#y),
        };
        ctx.setTransform(quantizedScale, 0, 0, quantizedScale, quantizedTranslation.x, quantizedTranslation.y);
      }

      addChangeCallback(changeCallback) {
        this.#changeCallbacks.push(changeCallback);
      }

      #changed() {
        this.#changeCallbacks.forEach(changeCallback => { changeCallback(); });
      }
    }

    class PanZoomController {
      #maxScale = 1000;
      #minScale = .07;

      #camera;
      #canvas;
      #pinchScaleHistory = []; // { scale, screenSpaceScaleFocus: { x, y }, time }
      #pressedPointerHistory = new Map(); // [{x, y, time, globalStateSnapshot}, ...]
      #globalPressedPointerStats = {
        pointerCount: 0,
        centerOfAllPointers: { x: 0, y: 0 },
        sumOfAllDistancesBetweenPointers: 0,
      };
      #panVelocity = { x: 0, y: 0 };
      #scaleVelocity = 0;
      #scaleVelocityIsFromPinch = false;
      #animatedScaleFocus = { x: 0, y: 0 };
      #previousFrameTimeStamp = null;
      #animationRequested = false;

      constructor(camera, canvas) {
        this.#camera = camera;
        this.#canvas = canvas;
        Object.seal(this);

        this.#canvas.addEventListener('pointerdown',   e => { this.#pointerDown(e);       });
        this.#canvas.addEventListener('pointermove',   e => { this.#pointerMove(e);       });
        this.#canvas.addEventListener('pointerup',     e => { this.#pointerUpOrCancel(e); });
        this.#canvas.addEventListener('pointercancel', e => { this.#pointerUpOrCancel(e); });
        this.#canvas.addEventListener('wheel',         e => { this.#wheel(e); });
      }

      stop() {
        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;
        this.#scaleVelocity = 0;
      }

      #removePointerFromPressedPointerHistory(pointerId) {
        this.#pressedPointerHistory.delete(pointerId);
        this.#recalculatePressedPointerStats();
      }

      #recalculatePressedPointerStats() {
        const mostRecentPointerEvents = [...this.#pressedPointerHistory.values()].map(pointerHistory => pointerHistory[pointerHistory.length-1]);
        let distanceCount = 0;
        let sumOfAllDistancesBetweenPointers = 0;
        let sumOfAllPointerPositions = { x: 0, y: 0 };
        for (let i = 0; i < mostRecentPointerEvents.length; i++) {
          let ev1 = mostRecentPointerEvents[i];
          sumOfAllPointerPositions.x += ev1.x;
          sumOfAllPointerPositions.y += ev1.y;
          for (let j = i+1; j < mostRecentPointerEvents.length; j++) {
            let ev2 = mostRecentPointerEvents[j];
            sumOfAllDistancesBetweenPointers += Math.hypot(ev1.x - ev2.x, ev1.y - ev2.y);
            distanceCount += 1;
          }
        }
        this.#globalPressedPointerStats = {
          centerOfAllPointers: {
            x: sumOfAllPointerPositions.x / this.#pressedPointerHistory.size,
            y: sumOfAllPointerPositions.y / this.#pressedPointerHistory.size,
          },
          sumOfAllDistancesBetweenPointers,
          pointerCount: this.#pressedPointerHistory.size,
        };
      }

      #addEventToPressedPointerHistory(e) {
        // get history array (or create empty one)
        let history = this.#pressedPointerHistory.get(e.pointerId);
        if (history === undefined) {
          history = [];
          this.#pressedPointerHistory.set(e.pointerId, history);
        };

        // prune old events
        const cutoff = e.timeStamp - 50;
        while (history.length > 0 && history[0].time < cutoff) {
          history.shift();
        }

        const cssToDevicePixelRatio = window.devicePixelRatio || 1;
        const ex = e.x * cssToDevicePixelRatio;
        const ey = e.y * cssToDevicePixelRatio;

        let newEvent = {
          x: ex,
          y: ey,
          time: e.timeStamp,
        };
        history.push(newEvent);
        this.#recalculatePressedPointerStats();
        newEvent.globalStateSnapshot = this.#globalPressedPointerStats;
      }

      #appendPinchScaleHistory(scale, scaleFocusX, scaleFocusY, time) {
        this.#pinchScaleHistory.push({scale, screenSpaceScaleFocus: { x: scaleFocusX, y: scaleFocusY }, time});
        const cutoff = time - 50;
        while (this.#pinchScaleHistory.length > 0 && this.#pinchScaleHistory[0].time < cutoff) {
          this.#pinchScaleHistory.shift();
        }
      }

      #pointerDown(e) {
        const cssToDevicePixelRatio = window.devicePixelRatio || 1;
        const ex = e.x * cssToDevicePixelRatio;
        const ey = e.y * cssToDevicePixelRatio;

        // ignore right click
        if (e.pointerType === 'mouse' && e.button === 2) return;

        this.#addEventToPressedPointerHistory(e);
        this.#appendPinchScaleHistory(this.#camera.scale, ex, ey, e.timeStamp);
        this.#canvas.setPointerCapture(e.pointerId);
      }

      #pointerMove(e) {
        // pointer that moved is not pressed (mouse hover)
        if (!this.#pressedPointerHistory.has(e.pointerId)) return;

        const oldCenter = this.#globalPressedPointerStats.centerOfAllPointers;
        const oldDistance = this.#globalPressedPointerStats.sumOfAllDistancesBetweenPointers;

        this.#addEventToPressedPointerHistory(e);

        const newCenter = this.#globalPressedPointerStats.centerOfAllPointers;
        const newDistance = this.#globalPressedPointerStats.sumOfAllDistancesBetweenPointers;

        const oldWorldPos = this.#camera.screenToWorld(oldCenter.x, oldCenter.y, this.#canvas.width, this.#canvas.height);
        const pointerCount = this.#globalPressedPointerStats.pointerCount;
        this.#camera.scale *= (oldDistance === 0) ? 1 : Math.pow(newDistance/oldDistance, pointerCount-1);
        this.#camera.scale = Math.min(Math.max(this.#camera.scale, this.#minScale), this.#maxScale);
        const newWorldPos = this.#camera.screenToWorld(newCenter.x, newCenter.y, this.#canvas.width, this.#canvas.height);
        this.#camera.x += oldWorldPos.x - newWorldPos.x;
        this.#camera.y += oldWorldPos.y - newWorldPos.y;

        this.#appendPinchScaleHistory(this.#camera.scale, newCenter.x, newCenter.y, e.timeStamp);

      }

      #calculatePanVelocity(e) {
        const history = this.#pressedPointerHistory.get(e.pointerId);

        // only look at the events with the maximum pointer count in the history
        // e.g. if there was a pinch, ignore the inevitable single pointer events at the end
        const maxPointerCount = Math.max(...history.map(ev => ev.globalStateSnapshot.pointerCount));
        const filteredHistory = history.filter(ev => ev.globalStateSnapshot.pointerCount === maxPointerCount);

        const firstEvent = filteredHistory[0];
        const lastEvent  = filteredHistory[filteredHistory.length - 1];

        const panDeltaTime = lastEvent.time - firstEvent.time;
        if (panDeltaTime === 0) {
          this.#panVelocity.x = 0;
          this.#panVelocity.y = 0;
        } else {
          this.#panVelocity.x = -this.#camera.screenToWorldDistance((lastEvent.globalStateSnapshot.centerOfAllPointers.x - firstEvent.globalStateSnapshot.centerOfAllPointers.x) / panDeltaTime);
          this.#panVelocity.y = -this.#camera.screenToWorldDistance((lastEvent.globalStateSnapshot.centerOfAllPointers.y - firstEvent.globalStateSnapshot.centerOfAllPointers.y) / panDeltaTime);
        }
      }

      #calculateScaleVelocity() {
        const firstScale = this.#pinchScaleHistory[0];
        const lastScale  = this.#pinchScaleHistory[this.#pinchScaleHistory.length - 1];

        const scaleDeltaTime = lastScale.time - firstScale.time;
        if (scaleDeltaTime === 0) {
          this.#scaleVelocity = 0;
        } else {
          this.#scaleVelocity = Math.log(lastScale.scale / firstScale.scale) / scaleDeltaTime;
          this.#scaleVelocityIsFromPinch = true;
        }
        this.#animatedScaleFocus = firstScale.screenSpaceScaleFocus;
      }

      #pointerUpOrCancel(e) {
        // ignore untracked pointer events
        if (this.#pressedPointerHistory.get(e.pointerId) === undefined) return;

        if (this.#pressedPointerHistory.size === 1) {
          const cssToDevicePixelRatio = window.devicePixelRatio || 1;
          const ex = e.x * cssToDevicePixelRatio;
          const ey = e.y * cssToDevicePixelRatio;

          // scale velocity
          this.#appendPinchScaleHistory(this.#camera.scale, ex, ey, e.timeStamp);
          this.#calculateScaleVelocity();

          if (this.#scaleVelocity === 0) {
            // pan velocity
            this.#addEventToPressedPointerHistory(e);
            this.#calculatePanVelocity(e);
          } else {
            this.#panVelocity.x = 0;
            this.#panVelocity.y = 0;
          }

          // fully released -> fling
          this.#requestAnimation();
        }
        this.#removePointerFromPressedPointerHistory(e.pointerId);
        this.#canvas.releasePointerCapture(e.pointerId);
      }

      #wheel(e) {
        e.preventDefault();
        if (e.deltaY === 0) return;

        const cssToDevicePixelRatio = window.devicePixelRatio || 1;
        const ex = e.x * cssToDevicePixelRatio;
        const ey = e.y * cssToDevicePixelRatio;
        const edeltaY = e.deltaY * cssToDevicePixelRatio;

        let scaleFactor;
        if (e.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          scaleFactor = Math.pow(1.1, -edeltaY/120);
        } else {
          scaleFactor = (edeltaY > 0 ? 1/1.1 : 1.1);
        }

        const scaleVelocityChange = -edeltaY/40000;
        if (Math.sign(this.#scaleVelocity) !== Math.sign(scaleVelocityChange)) {
          this.#scaleVelocity = 0;
        }
        this.#scaleVelocity += scaleVelocityChange;
        this.#scaleVelocityIsFromPinch = false;
        this.#animatedScaleFocus.x = ex;
        this.#animatedScaleFocus.y = ey;

        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;

        this.#requestAnimation();
      }

      #requestAnimation() {
        if (this.#animationRequested) return;
        window.requestAnimationFrame((t) => {
          this.#animationRequested = false;
          let dt = 16.6;
          if (this.#previousFrameTimeStamp !== null) {
            dt = Math.min(t - this.#previousFrameTimeStamp, 100);
          }
          this.#previousFrameTimeStamp = t;
          this.#animate(dt);
        });
        this.#animationRequested = true;
      }

      #animate(dt) {
        if (this.#pressedPointerHistory.size === 0) {

          this.#camera.x += this.#panVelocity.x * dt;
          this.#camera.y += this.#panVelocity.y * dt;
          this.#panVelocity.x *= .95;
          this.#panVelocity.y *= .95;

          const targetWorldPos = this.#camera.screenToWorld(this.#animatedScaleFocus.x, this.#animatedScaleFocus.y, this.#canvas.width, this.#canvas.height);
          this.#camera.scale *= Math.exp(this.#scaleVelocity * dt);
          this.#camera.scale = Math.min(Math.max(this.#camera.scale, this.#minScale), this.#maxScale);
          const scaledWorldPos = this.#camera.screenToWorld(this.#animatedScaleFocus.x, this.#animatedScaleFocus.y, this.#canvas.width, this.#canvas.height);
          this.#camera.x += targetWorldPos.x - scaledWorldPos.x;
          this.#camera.y += targetWorldPos.y - scaledWorldPos.y;
          if (this.#scaleVelocityIsFromPinch) {
            this.#scaleVelocity *= .9;
          } else {
            this.#scaleVelocity *= .8;
          }

          if (Math.abs(this.#scaleVelocity) > .0001 || this.#camera.worldToScreenDistance(Math.hypot(this.#panVelocity.x, this.#panVelocity.y)) > .01) {
            this.#requestAnimation();
            return;
          }
        }
        this.#previousFrameTimeStamp = null;
        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;
        this.#scaleVelocity = 0;
      }
    }



    // ========== LAYERS ==========
    const TILE_SIZE = 512;
    let DEBUG_FETCHSTOP = false;
    class MapLayer {
      // create MapLayer's
      static async fromPath(path, onTile) {
        if (path.endsWith('.png')) {
          const res = await fetch(path);
          const blob = await res.blob();
          const image = await createImageBitmap(blob);
          const fileName = path.substring(path.lastIndexOf('/') + 1);
          return await MapLayer.fromImage(image, onTile, fileName);
        }
        // fetch lod file list
        const tileListPath = `${path}/tile_list.txt`;
        const tileListResponse = await fetch(tileListPath);
        if (!tileListResponse.ok) {
          throw new Error(`failed to fetch tile list from ${tileListPath}: ${tileListResponse.status} ${tileListResponse.statusText}`);
        }
        const tileList = new Set((await tileListResponse.text()).split('\n'));

        const mapLayer = new MapLayer((lod, x, y) => MapLayer.#fetchTileFromPath(lod, x, y, path, tileList), onTile);

        // fetch metadata
        const metadataPath = `${path}/metadata.json`;
        const matadataResponse = await fetch(metadataPath);
        if (!matadataResponse.ok) {
          throw new Error(`failed to fetch map metadata from ${metadataPath}: ${matadataResponse.status} ${matadataResponse.statusText}`);
        }
        try {
          mapLayer.metadata = JSON.parse(await matadataResponse.text());
          mapLayer.metadata.maxLod = mapLayer.metadata.maxLod || 0;
          mapLayer.metadata.scale = mapLayer.metadata.scale || 1;
        } catch (parseError) {
          throw new Error(`could not parse map metadata from ${metadataPath}: ${parseError.message}`);
        }

        return mapLayer;
      }

      static async fromImage(image, onTile, fileName = '') {
        const matchesX     = [...fileName.matchAll(/x(-?\d+(?:\.\d+)?)/g)];
        const matchesZ     = [...fileName.matchAll(/z(-?\d+(?:\.\d+)?)/g)];
        const matchesScale = [...fileName.matchAll(/scale(-?\d+(?:\.\d+)?)/g)];

        const topLeftX = (matchesX    .length > 0) ? parseFloat(matchesX    .at(-1)[1]) : NaN;
        const topLeftY = (matchesZ    .length > 0) ? parseFloat(matchesZ    .at(-1)[1]) : NaN;
        const scale    = (matchesScale.length > 0) ? parseFloat(matchesScale.at(-1)[1]) : 1;

        const processed = await MapLayer.#preprocessMapImage(image, topLeftX, topLeftY);
        if (processed == null) return null;
        const mapLayer = new MapLayer(
          (lod, x, y) => MapLayer.#createTileFromImage(lod, x, y, processed.image, processed.topLeftX, processed.topLeftY),
          onTile
        );
        mapLayer.metadata = {
          width: processed.image.width,
          height: processed.image.height,
          topLeft: {
            x: processed.topLeftX,
            y: processed.topLeftY,
          },
          maxLod: 0,
          scale: scale,
        };
        return mapLayer;
      }

      fitCamera(camera, canvas) {
        const screenWidth  = this.metadata.width  * this.metadata.scale;
        const screenHeight = this.metadata.height * this.metadata.scale;
        const scaleX = canvas.width  / (screenWidth  * 1.1);
        const scaleY = canvas.height / (screenHeight * 1.1);
        camera.scale = Math.min(scaleX, scaleY);
        camera.x = this.metadata.topLeft.x * this.metadata.scale + screenWidth  / 2;
        camera.y = this.metadata.topLeft.y * this.metadata.scale + screenHeight / 2;
      }

      // crops black pixels and makes remaining black pixels transparent
      // notes:
      // - returns null if bitmap is completely black
      // (mapImage: ImageBitmap) -> ImageBitmap
      static async #preprocessMapImage(mapImage, topLeftX, topLeftY) {
        const width = mapImage.width;
        const height = mapImage.height;

        // convert bitmap to canvas
        const canvas = new OffscreenCanvas(width, height);
        const canvasContext = canvas.getContext('2d');
        canvasContext.drawImage(mapImage, 0, 0);

        // make black pixels transparent and find bounding rectangle of non-black pixels
        let minX = width;
        let minY = height;
        let maxX = -1;
        let maxY = -1;
        const imageData = canvasContext.getImageData(0, 0, width, height);
        const pixels = imageData.data;
        for (let y = 0, i = 0; y < height; y++) {
          for (let x = 0; x < width; x++, i += 4) {
            // check if r, g and b are all 0 (i.e. the pixel is black)
            if ((pixels[i] | pixels[i+1] | pixels[i+2]) === 0) {
              pixels[i+3] = 0; // make pixel transparent
            } else {
              pixels[i+3] = 255; // ensure pixel is opaque
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
            }
          }
        }
        if (maxX < minX) return null; // all pixels were black and would now be transparent
        canvasContext.putImageData(imageData, 0, 0);

        // crop image and return it
        const croppedWidth = maxX - minX + 1;
        const croppedHeight = maxY - minY + 1;
        return {
          image: await createImageBitmap(canvas, minX, minY, croppedWidth, croppedHeight),
          topLeftX: (topLeftX + minX) || 0,
          topLeftY: (topLeftY + minY) || 0,
        };
      }


      // obtain tiles
      static async #fetchTileFromPath(lod, x, y, path, tileList) {
        const fileName = `lod${lod}_x${x}_z${y}.png`;
        if (!tileList.has(fileName)) return null;

        const res = await fetch(`${path}/${fileName}`);
        if (res.status === 404) return null;
        if (!res.ok) throw new Error(`failed to fetch lod: ${res.status}`);
        const blob = await res.blob();
        return await createImageBitmap(blob);
      }

      static async #createTileFromImage(lod, x, y, image, topLeftX, topLeftY) {
        const tileSize = TILE_SIZE * Math.pow(2, lod);
        //const offsetX = 3453 - 7578 + 317 - x * tileSize;
        //const offsetY = 1213 - 3746 +  21 - y * tileSize;
        const offsetX = topLeftX - x * tileSize;
        const offsetY = topLeftY - y * tileSize;

        // requested tile is outside of image
        if (offsetX < -image.width || offsetY < -image.height) return null;
        if (offsetX > tileSize || offsetY > tileSize) return null;

        await new Promise(r => setTimeout(r, Math.floor(Math.random() * 100) + 100));
        const osc = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
        const ctx = osc.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.clearRect(0, 0, osc.width, osc.height);
        ctx.drawImage(image, -offsetX, -offsetY, tileSize, tileSize, 0, 0, osc.width, osc.height);
        const data = ctx.getImageData(0, 0, osc.width, osc.height).data;

        // skip fully transparent tiles
        for (let i = 3; i < data.length; i += 4) {
          if (data[i] !== 0) {
            return osc.transferToImageBitmap();
          }
        }
        return null;
      }



      #fetchTile;
      #onTile;

      metadata;

      #maxConcurrentFetches = 6;
      #tiles = new Map();
      #inflightTileKeys = new Set();
      #nonExistentTiles = new Set();
      #queue = null;

      constructor(fetchTile, onTile) {
        this.#fetchTile = fetchTile;
        this.#onTile = onTile;
        Object.seal(this);
      }

      async exportLods() {
        const metadataBlob = new Blob([JSON.stringify(this.metadata)], { type: "application/json" });
        const blobs = [{ name: 'metadata.json', blob: metadataBlob }];

        let lodFileNames = [];

        const canvas = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
        const ctx = canvas.getContext("2d");
        for (const [key, tile] of this.#tiles.entries()) {
          const { x, y, lod } = this.#unpackKey(key);
          const name = `lod${lod}_x${x}_z${y}.png`;
          lodFileNames.push(name);
          console.log(name);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(tile, 0, 0);
          blobs.push({ name, blob: await canvas.convertToBlob() });
        }

        let lodFileNamesBlob = new Blob([lodFileNames.sort().join('\n')], { type: 'text/plain' });
        blobs.push({ name: 'tile_list.txt', blob: lodFileNamesBlob });

        return blobs;
      }

      calculateLod(camera) {
        return Math.max(0, Math.floor(-Math.log(camera.scale * this.metadata.scale)/Math.log(2)));
      }

      calculateScreenSpaceTileSize(lod) {
        return TILE_SIZE * Math.pow(2, lod) * this.metadata.scale;
      }

      // assumes camera.apply() has been called already
      draw(canvasContext, camera) {
        const canvasWorldWidth = camera.screenToWorldDistance(canvasContext.canvas.width);
        const canvasWorldHeight = camera.screenToWorldDistance(canvasContext.canvas.height);

        const lod = this.calculateLod(camera);
        const screenSpaceTileSize = this.calculateScreenSpaceTileSize(lod);

        const minTileX = Math.floor((camera.x - canvasWorldWidth  / 2) / screenSpaceTileSize);
        const minTileY = Math.floor((camera.y - canvasWorldHeight / 2) / screenSpaceTileSize);
        const maxTileX = Math.floor((camera.x + canvasWorldWidth  / 2) / screenSpaceTileSize);
        const maxTileY = Math.floor((camera.y + canvasWorldHeight / 2) / screenSpaceTileSize);

        for (let tileX = minTileX; tileX <= maxTileX; tileX++) {
          for (let tileY = minTileY; tileY <= maxTileY; tileY++) {
            let image = undefined;
            let lodOffset = 0;
            let lodOffsetPow;
            while (lodOffset < 4) {
              lodOffsetPow = Math.pow(2, lodOffset);
              image = this.#tiles.get(this.#tileKey(Math.floor(tileX/lodOffsetPow), Math.floor(tileY/lodOffsetPow), lod  + lodOffset));
              if (image !== undefined) break;
              lodOffset += 1;
            }
            if (image === undefined) continue;
            const fromX = ((tileX % lodOffsetPow) + lodOffsetPow) % lodOffsetPow / lodOffsetPow * image.width;
            const fromY = ((tileY % lodOffsetPow) + lodOffsetPow) % lodOffsetPow / lodOffsetPow * image.height;
            canvasContext.drawImage(
              image,
              fromX,
              fromY,
              image.width / lodOffsetPow,
              image.height / lodOffsetPow,
              tileX * screenSpaceTileSize,
              tileY * screenSpaceTileSize,
              screenSpaceTileSize,
              screenSpaceTileSize
            );
          }
        }

        const centerTileX = Math.floor(camera.x / screenSpaceTileSize);
        const centerTileY = Math.floor(camera.y / screenSpaceTileSize);

        this.#queue =
          (function* (lod, centerTileX, centerTileY, minTileX, minTileY, maxTileX, maxTileY, maxLod) {
            if (lod < maxLod) {
              lod = maxLod;
              const pow = Math.pow(2, maxLod-lod);
              centerTileX = Math.floor(centerTileX * pow);
              centerTileY = Math.floor(centerTileY * pow);
              minTileX = Math.floor(minTileX * pow);
              minTileY = Math.floor(minTileY * pow);
              maxTileX = Math.floor(maxTileX * pow);
              maxTileY = Math.floor(maxTileY * pow);
            }
            for (; lod >= 0; lod--) {
              for (const { x, y } of boundedDiamondPattern(centerTileX, centerTileY, minTileX, minTileY, maxTileX, maxTileY)) {
                yield { x, y, lod };
              }
              centerTileX = centerTileX * 2;
              centerTileY = centerTileY * 2;
              minTileX = minTileX * 2;
              minTileY = minTileY * 2;
              maxTileX = maxTileX * 2;
              maxTileY = maxTileY * 2;
            }
          })(lod, centerTileX, centerTileY, minTileX, minTileY, maxTileX, maxTileY, this.metadata?.maxLod || lod)
          .map( ({x, y, lod }) => ({x, y, lod, key: this.#tileKey(x, y, lod)}) )
          .filter( ({x, y, lod, key}) => !this.#tiles           .has(key) )
          .filter( ({x, y, lod, key}) => !this.#inflightTileKeys.has(key) )
          .filter( ({x, y, lod, key}) => !this.#nonExistentTiles.has(key) );

        this.#triggerFetches();
      }

      #triggerFetches() {
        if (DEBUG_FETCHSTOP) return;
        while (this.#inflightTileKeys.size < this.#maxConcurrentFetches) {
          const tile = this.#queue.next().value;
          if (tile === undefined) return;
          this.#inflightTileKeys.add(tile.key);
          this.#fetchTile(tile.lod, tile.x, tile.y)
            .then(image => {
              if (image === null) {
                this.#nonExistentTiles.add(tile.key)
              } else {
                this.#tiles.set(tile.key, image);
                this.metadata.maxLod = Math.max(this.metadata.maxLod, tile.lod);
                this.#onTile();
              }
            })
            .catch(error => {
              // TODO
            })
            .finally(() => {
              this.#inflightTileKeys.delete(tile.key);
              this.#triggerFetches();
            });
        }
      }

      #tileKey(x, y, lod) {
        return (x + 0x800000) * (1 << 28) + (y + 0x800000) * (1 << 4) + lod;
      }

      #unpackKey(key) {
        const lod = key & 0xF;
        const y   = ((key >> 4) & 0xFFFFFF) - 0x800000;
        const x   = Math.floor(key / (1 << 28)) - 0x800000;
        return { x, y, lod };
      }
    }



    // ========== MARKERS ==========
    function drawMarker(marker, ctx, camera, onRedrawNeeded) {
      drawMarker.icons = drawMarker.icons || new Map();
      const icons = drawMarker.icons;

      const posX = marker.x || 0;
      const posY = marker.z || 0;

      const cssToDevicePixelRatio = window.devicePixelRatio || 1;
      const screenPos = camera.worldToScreen(posX + .5, posY + .5, ctx.canvas.width, ctx.canvas.height);

      if (marker.text) {
        const textSizeMap         = marker.textSizeMap             || 95;
        const textSizeScreen      = marker.textSizeScreen          || textSizeMap / 2;
        ctx.textAlign             = marker.textAlign               || 'center';
        ctx.textBaseline          = marker.textBaseline            || 'middle';
        ctx.strokeStyle           = marker.textStrokeStyle         || '#000';
        ctx.fillStyle             = marker.textFillStyle           || '#f00';
        const lineWidthPercentage = marker.textLineWidthPercentage || .075;

        const textSize = Math.min(textSizeMap * camera.scale, textSizeScreen * cssToDevicePixelRatio);
        ctx.font = `${textSize}px MinecraftItalic`;
        // * 2 because half of strokeText() is overdrawn by fillText()
        ctx.lineWidth = lineWidthPercentage * 2 * textSize;

        ctx.strokeText(marker.text, screenPos.x, screenPos.y);
        ctx.fillText(marker.text, screenPos.x, screenPos.y);
      } else if (marker.iconPath) {
        const icon = icons.get(marker.iconPath);
        if (icon === undefined) {
          fetch(marker.iconPath)
            .then(response => {
              if (response.status === 404) icons.set(marker.iconPath, null);
              else if (!response.ok) throw new Error(`failed to fetch icon: ${res.status}`);
              else return response.blob();
            })
            .then(blob => createImageBitmap(blob))
            .then(image => {
              icons.set(marker.iconPath, image);
              onRedrawNeeded();
            })
            .catch(err => {
              // TODO
            });
        } else if (marker !== null) {
          const iconScaleMap    = marker.iconScaleMap    || 6;
          const iconScaleScreen = marker.iconScaleScreen || iconScaleMap / 2;
          const iconScale = Math.min(iconScaleMap * camera.scale, iconScaleScreen * cssToDevicePixelRatio);
          ctx.drawImage(icon, screenPos.x - icon.width/2 * iconScale, screenPos.y - icon.height/2 * iconScale, icon.width * iconScale, icon.height * iconScale);
        }
      }
    }



    // ========== GLOBALS ==========
    const mainCanvas = document.getElementById('main-canvas');
    const hudX = document.getElementById('hud-x');
    const hudZ = document.getElementById('hud-z');

    const mainCanvasContext = mainCanvas.getContext('2d');
    const mainCamera = new Camera();
    const cameraPanZoomController = new PanZoomController(mainCamera, mainCanvas);

    let activeLayerIndex = 0;
    let layers = [];

    let animationFrameRequested = false;

    let clickedWorldCoords = null;

    let showMarkers = false;
    let markers = [
      { x:  2784, z:  -376, y: 125, iconPath: '/icons/redstone.png'    },
      { x:   946, z:  -374, y: 142, iconPath: '/icons/coal.png'        },
      { x:   615, z:  -781, y:  98, iconPath: '/icons/diamond.png'      },
      { x:  2433, z:  -661, y:  82, iconPath: '/icons/diamond.png'      },
      { x:   958, z:   995, y:  92, iconPath: '/icons/gold_ingot.png'   },
      { x:   896, z:  -356, y: 142, iconPath: '/icons/gold_ingot.png'   },
      { x:  2738, z:   647, y:  78, iconPath: '/icons/iron_ingot.png'   },
      { x:  1657, z:  -287, y:  69, iconPath: '/icons/iron_ingot.png'   },
      { x:  1380, z:   630, y: 139, iconPath: '/icons/iron_ingot.png'   },
      { x:  1478, z: -1467, y: 137, iconPath: '/icons/lapis_lazuli.png' },
      { x:  -114, z:  1150, y: 120, iconPath: '/icons/lapis_lazuli.png' },
      { x:  -558, z:   173, y:  74, iconPath: '/icons/redstone.png'    },
      { x:  -528, z:  -531, y: 110, iconPath: '/icons/lapis_lazuli.png' },
      { x: -1408, z:  -781, y: 212, iconPath: '/icons/coal.png'        },
      { x: -1794, z:  -163, y: 132, iconPath: '/icons/iron_ingot.png'   },
      { x: -1269, z:   -51, y:  83, iconPath: '/icons/copper_ingot.png'   },
      { x: -1532, z:   700, y: 120, iconPath: '/icons/iron_ingot.png'   },
      { x: -1509, z:   882, y: 108, iconPath: '/icons/coal.png'        },
      { x: -1558, z:   854, y: 106, iconPath: '/icons/iron_ingot.png'   },
      { x: -2012, z:   901, y: 101, iconPath: '/icons/diamond.png'      },
      { x: -2855, z:   981, y: 116, iconPath: '/icons/coal.png'        },
      { x: -2798, z:  -673, y: 114, iconPath: '/icons/coal.png'        },
      { x: -2939, z:  -858, y:  92, iconPath: '/icons/iron_ingot.png'   },
      { x:  -414, z:  1594, y: 111, iconPath: '/icons/redstone.png'    },
      { x:  -324, z:   690, y: 107, iconPath: '/icons/coal.png'        },
      { x:  -324, z:   686, y: 110, iconPath: '/icons/iron_ingot.png'   },
      { x:  -482, z: -1096, y:  88, iconPath: '/icons/iron_ingot.png'   },

      { x:  2268, z:  -751, textFillStyle: '#f300f3', textSizeMap: 95,  text: 'Renkai'                  },
      { x:  2553, z: -1452, textFillStyle: '#fe3333', textSizeMap: 95,  text: 'Northelios'              },
      { x:  2683, z:   452, textFillStyle: '#de8644', textSizeMap: 103, text: 'Imperium'                },
      { x:   973, z:  -260, textFillStyle: '#f90120', textSizeMap: 109, text: 'Sarkovia'                },
      { x:  1722, z:  -416, textFillStyle: '#6767ea', text: 'Polestar'                },
      //{ x:  2275, z:  -378, textFillStyle: '#f35e0e', textBaseline: 'top',    text: 'Oranjestad'             },
      //{ x:  2458, z:  -426, textFillStyle: '#8be6f0', textBaseline: 'bottom', text: 'The Federation of Ironhill' },
      //{ x:  2429, z:  -553, textFillStyle: '#f300f3', textBaseline: 'bottom', text: 'Hoseki D.O.' },
      { x:  -505, z:   515, textFillStyle: '#ffdd33', textSizeMap: 143, text: 'Kingdom of Chimera'   },
      { x:   -59, z:  1506, textFillStyle: '#559b16', textSizeMap: 78, text: 'The SWTZ'                },
      { x:  3049, z:  1277, textFillStyle: '#56935b', textSizeMap: 74, textAlign: 'left', text: '  Harvestspire'            },
      { x:  2655, z:  1176, textFillStyle: '#fffa96', textSizeMap: 85, text: 'Universale'            },
      { x: -2363, z:   524, textFillStyle: '#32ed22', textSizeMap: 78, text: 'El Gran Cartel'          },
      { x: -1387, z:  -949, textFillStyle: '#bbdc65', textSizeMap: 88, text: 'Helioria'                },
      { x:  -113, z: -1342, textFillStyle: '#43a6d9', text: 'Pantha'                  },

      { x:  1421, z:  1124, textFillStyle: '#b9bbcc', text: 'Checkerboard Union'      },
      { x: -2910, z: - 543, textFillStyle: '#d1502f', text: 'Soup Bowl'               },
      { x:  1583, z: -1323, textFillStyle: '#8667de', text: 'Penguinia'               },
    ];

    document.addEventListener('keydown', e => {
      if (e.code === 'Tab') {
        e.preventDefault();
        let textbox = document.getElementById('textbox').hidden = true;
        showMarkers = !showMarkers;
        requestRender();
      } else if (e.code === 'Space') {
        const activeLayer = layers.at(activeLayerIndex);
        cameraPanZoomController.stop();
        activeLayer.fitCamera(mainCamera, mainCanvas);
      } else if ('0' <= e.key && e.key <= '9') {
        const newIndex = e.key - 1; // coerce digit to number by subtracting
        if (activeLayerIndex !== newIndex) {
          activeLayerIndex = newIndex;
          requestRender();
        }
      }
    });



    // ========== COORDS  ==========
    mainCanvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      const cssToDevicePixelRatio = window.devicePixelRatio || 1;
      const ex = e.x * cssToDevicePixelRatio;
      const ey = e.y * cssToDevicePixelRatio;
      let newClickedWorldCoords = mainCamera.screenToWorld(ex, ey, mainCanvas.width, mainCanvas.height);
      newClickedWorldCoords.x = Math.floor(newClickedWorldCoords.x);
      newClickedWorldCoords.y = Math.floor(newClickedWorldCoords.y);
      if (clickedWorldCoords != null && newClickedWorldCoords.x === clickedWorldCoords.x && newClickedWorldCoords.y === clickedWorldCoords.y) {
        clickedWorldCoords = null;
        window.history.replaceState({}, '', `${window.location.pathname}`);
        hudX.style.display = 'none';
        hudZ.style.display = 'none';
      } else {
        clickedWorldCoords = newClickedWorldCoords;
        window.history.replaceState({}, '', `${window.location.pathname}?${clickedWorldCoords.x},${clickedWorldCoords.y}`);
        hudX.textContent = clickedWorldCoords.x;
        hudZ.textContent = clickedWorldCoords.y;
        hudX.style.display = 'block';
        hudZ.style.display = 'block';
      }
      requestRender();
    });



    // ========== RENDER ==========
    mainCamera.addChangeCallback(() => { requestRender(); });

    function requestRender() {
      if (animationFrameRequested) return;
      window.requestAnimationFrame((t) => {
        animationFrameRequested = false;
        render(mainCanvasContext, mainCamera);
      });
      animationFrameRequested = true;
    }

    function render(ctx, camera) {
      ctx.resetTransform();
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.imageSmoothingEnabled = false;//camera.scale < 1;

      const activeLayer = layers.at(activeLayerIndex);
      if (activeLayer) {

      // quantize camera scale to hide tile seams
      const lod = activeLayer.calculateLod(camera);
      const tileSize = activeLayer.calculateScreenSpaceTileSize(lod);
      camera.apply(ctx, tileSize);

      if (activeLayer) activeLayer.draw(ctx, camera);
      } else {
        camera.apply
      }

      ctx.resetTransform();

      if (showMarkers) {
        ctx.fillStyle = '#0005';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        for (const marker of markers) {
          drawMarker(marker, ctx, camera, () => requestRender());
        }
      }

      if (clickedWorldCoords !== null) {
        let screenCoords = camera.worldToScreen(clickedWorldCoords.x + .5, clickedWorldCoords.y + .5, mainCanvas.width, mainCanvas.height);
        drawPin(ctx, screenCoords.x, screenCoords.y);
      }

    }

    function drawPin(ctx, x, y, color = '#F00') {
      const pinWidth = 32;
      const pinHeight = 26;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - pinWidth/2, y - pinHeight);
      ctx.lineTo(x + pinWidth/2, y - pinHeight);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }



    // ========== TOOLING ==========
    // downloadZip([{ name, blob }, ...], "archive.zip")
    async function downloadZip(files, zipName = 'archive.zip') {
      const te = new TextEncoder();
      const u16 = v => new Uint8Array([v & 255, v >> 8 & 255]);
      const u32 = v => new Uint8Array([v & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255]);

      // CRC32 table + fn
      const TABLE = (() => {
        const t = new Uint32Array(256);
        for (let i = 0; i < 256; i++) { let c = i; for (let k = 0; k < 8; k++) c = c & 1 ? 0xEDB88320 ^ (c >>> 1) : c >>> 1; t[i] = c >>> 0; }
        return t;
      })();
      const crc32 = bytes => { let c = ~0; for (let b of bytes) c = TABLE[(c ^ b) & 255] ^ (c >>> 8); return (c ^ -1) >>> 0; };

      const body = [], central = [];
      let offset = 0;

      for (let i = 0; i < files.length; i++) {
        const name = te.encode(files[i].name || `file${i}`);
        const data = new Uint8Array(await files[i].blob.arrayBuffer());
        const crc = crc32(data), size = data.length, localOffset = offset;

        // --- local file header ---
        body.push(
          u32(0x04034b50),   // local sig
          u16(20),           // version
          u16(0x0800),       // flags (UTF-8)
          u16(0),            // method (0 = store)
          u16(0), u16(0),    // time/date
          u32(crc),          // crc32
          u32(size),         // comp size
          u32(size),         // uncomp size
          u16(name.length),  // name len
          u16(0),            // extra len
          name,              // filename
          data               // file data
        );
        offset += 30 + name.length + size;

        // --- central directory entry ---
        central.push(
          u32(0x02014b50),   // central sig
          u16(20), u16(20),  // version made/needed
          u16(0x0800),       // flags (UTF-8)
          u16(0),            // method
          u16(0), u16(0),    // time/date
          u32(crc),
          u32(size), u32(size),
          u16(name.length),
          u16(0), u16(0),    // extra/comment len
          u16(0), u16(0),    // disk/internal attrs
          u32(0),            // external attrs
          u32(localOffset),  // local header offset
          name
        );
      }

      const centralSize = central.reduce((n, b) => n + b.length, 0);
      const centralStart = offset;

      // --- end of central dir ---
      const end = [
        u32(0x06054b50), // end sig
        u16(0), u16(0),  // disk nums
        u16(files.length), u16(files.length), // counts
        u32(centralSize),
        u32(centralStart),
        u16(0)           // comment len
      ];

      // zip blob
      const zipBlob = new Blob([...body, ...central, ...end], { type: "application/zip" });

      // trigger download
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = zipName;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function downloadLods() {
      const activeLayer = layers.at(activeLayerIndex);
      if (activeLayer) {
        downloadZip(await activeLayer.exportLods());
      }
    }



    // ========== EVENTS ==========
    window.addEventListener('resize', () => {
      const cssToDevicePixelRatio = window.devicePixelRatio || 1;
      let screenWidthInCssPixels = window.visualViewport?.width || window.innerWidth;
      let screenHeightInCssPixels = window.visualViewport?.height || window.innerHeight;
      mainCanvas.width = Math.round(screenWidthInCssPixels * cssToDevicePixelRatio);
      mainCanvas.height = Math.round(screenHeightInCssPixels * cssToDevicePixelRatio);
      requestRender();
    });

    (async () => {
      window.dispatchEvent(new Event('resize'));
      await document.fonts.load('32px MinecraftItalic');

      const mainLayer = await MapLayer.fromPath( 'mapdata/usgs_day11_v1', () => { requestRender(); } );
      cameraPanZoomController.stop();
      mainLayer.fitCamera(mainCamera, mainCanvas);
      layers.push(mainLayer);

      document.getElementById('loading').remove();
      let urlCoords = window.location.search.slice(1).split(',').map(Number);
      if (urlCoords.length == 2 && !Number.isNaN(urlCoords[0]) && !Number.isNaN(urlCoords[1])) {
        clickedWorldCoords = { x: Math.floor(urlCoords[0]), y: Math.floor(urlCoords[1]) };
        window.history.replaceState({}, '', `${window.location.pathname}?${clickedWorldCoords.x},${clickedWorldCoords.y}`);
        hudX.textContent = clickedWorldCoords.x;
        hudZ.textContent = clickedWorldCoords.y;
        hudX.style.display = 'block';
        hudZ.style.display = 'block';
      } else {
        window.history.replaceState({}, '', `${window.location.pathname}`);
      }
      window.setTimeout(() => { document.getElementById('textbox').hidden = true; }, 5000);
      requestRender();

      layers.push(await MapLayer.fromPath( 'mapdata/edi_day11_v1', () => { requestRender(); } ));
    })();
  </script>
</body>
</html>
