<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,">
  <title>mccivmap</title>
  <style>
    body { margin: 0; background: #000; color: #fff; font: 14px system-ui; }
    #main-canvas { position: fixed; width: 100%; height: 100%; touch-action: none; }
    #hud-x,#hud-z { display: none; background: #0008; position: fixed; top: 12px; padding: .3rem .6rem; border-radius: .4rem; pointer-events: none; font-variant-numeric: tabular-nums; }
    #hud-x { right: 50%; border-top-right-radius: 0; border-bottom-right-radius: 0; text-align: right; }
    #hud-z { left: 50%; border-top-left-radius: 0; border-bottom-left-radius: 0; text-align: left; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 9999; }
    @font-face { font-family: 'MinecraftItalic'; src: url('/fonts/MinecraftItalic-R8Mo.otf') format('opentype'); }
  </style>
</head>
<body>
  <div id="loading">loading map...</div>
  <canvas id="main-canvas"></canvas>
  <span id="hud-x">0</span>
  <span id="hud-z">0</span>
  <div id="textbox" style="position:fixed;top:0;left:0;padding:6px;font:16px monospace;max-width:90vw;word-wrap:break-word;">
    by @crazycraftix<br>
    TAB to show LABELS<br>
    NUMBERS switch MAPS
  </div>
  <script>
    'use strict';

    // ========== UTIL ==========
    function* boundedDiamondPattern(centerX, centerY, minX, minY, maxX, maxY) {
      yield { x: centerX, y: centerY };

      let yieldCount = 1;
      const totalYields = (maxX - minX + 1) * (maxY - minY + 1);

      for(let radius = 0; yieldCount < totalYields; radius++) {
        for(let i = 0; i < radius; i++) {
          const tileCoords = [
            { dx:  i,          dy:  radius - i },
            { dx: -i,          dy:  i - radius },
            { dx:  radius - i, dy: -i          },
            { dx:  i - radius, dy:  i          },
          ];
          for (const { dx, dy } of tileCoords) {
            const tileX = centerX + dx;
            if (tileX < minX || tileX > maxX) continue;
            const tileY = centerY + dy;
            if (tileY < minY || tileY > maxY) continue;
            yieldCount++;
            yield { x: tileX, y: tileY };
          }
        }
      }
    }



    // ========== CAMERA ==========
    class Camera {
      #x = 0;
      #y = 0;
      #scale = 1;
      #changeCallbacks = [];

      scaleQuantizationSize = null;

      get x()     { return this.#x;     }
      get y()     { return this.#y;     }
      get scale() { return this.#scale; }

      set x(v)     { this.#x = v;     this.#changed(); }
      set y(v)     { this.#y = v;     this.#changed(); }
      set scale(v) { this.#scale = v; this.#changed(); }

      constructor() {
        Object.seal(this);
      }

      worldToScreen(x, y, screenWidth, screenHeight, quantize = false) {
        const scale = quantize ? this.quantizedScale() : this.#scale;
        return quantize ? {
          x: x * scale + Math.round(screenWidth /2 - this.#x * scale),
          y: y * scale + Math.round(screenHeight/2 - this.#y * scale),
        } : {
          x: (x - this.#x) * scale + screenWidth /2,
          y: (y - this.#y) * scale + screenHeight/2,
        };
      }

      screenToWorld(x, y, screenWidth, screenHeight, quantize = false) {
        const scale = quantize ? this.quantizedScale() : this.#scale;
        return {
          x: (x - screenWidth /2) / scale + this.#x,
          y: (y - screenHeight/2) / scale + this.#y,
        };
      }

      worldToScreenDistance(value, quantize = false) { return value * (quantize ? this.quantizedScale() : this.#scale); }
      screenToWorldDistance(value, quantize = false) { return value / (quantize ? this.quantizedScale() : this.#scale); }

      apply(ctx, quantize = false) {
        const scale = quantize ? this.quantizedScale() : this.#scale;

        const translation = this.worldToScreen(0, 0, ctx.canvas.width, ctx.canvas.height, quantize);

        ctx.setTransform(scale, 0, 0, scale, translation.x, translation.y);
      }

      addChangeCallback(changeCallback) {
        this.#changeCallbacks.push(changeCallback);
      }

      quantizedScale() {
        if (this.scaleQuantizationSize === null) return this.#scale;
        return Math.round(this.#scale * this.scaleQuantizationSize) / this.scaleQuantizationSize;
      }

      #changed() {
        this.#changeCallbacks.forEach(changeCallback => { changeCallback(); });
      }
    }

    class PanZoomController {
      #maxScale = 1000;
      #minScale = .07;

      #camera;
      #canvas;
      #pinchScaleHistory = []; // { scale, screenSpaceScaleFocus: { x, y }, time }
      #pressedPointerHistory = new Map(); // [{x, y, time, globalStateSnapshot}, ...]
      #globalPressedPointerStats = {
        pointerCount: 0,
        centerOfAllPointers: { x: 0, y: 0 },
        sumOfAllDistancesBetweenPointers: 0,
      };
      #panVelocity = { x: 0, y: 0 };
      #scaleVelocity = 0;
      #scaleVelocityIsFromPinch = false;
      #animatedScaleFocus = { x: 0, y: 0 };
      #previousFrameTimeStamp = null;
      #animationRequested = false;

      constructor(camera, canvas) {
        this.#camera = camera;
        this.#canvas = canvas;
        Object.seal(this);

        this.#canvas.addEventListener('pointerdown',   e => { this.#pointerDown(e);       });
        this.#canvas.addEventListener('pointermove',   e => { this.#pointerMove(e);       });
        this.#canvas.addEventListener('pointerup',     e => { this.#pointerUpOrCancel(e); });
        this.#canvas.addEventListener('pointercancel', e => { this.#pointerUpOrCancel(e); });
        this.#canvas.addEventListener('wheel',         e => { this.#wheel(e); });
      }

      stop() {
        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;
        this.#scaleVelocity = 0;
      }

      #removePointerFromPressedPointerHistory(pointerId) {
        this.#pressedPointerHistory.delete(pointerId);
        this.#recalculatePressedPointerStats();
      }

      #recalculatePressedPointerStats() {
        const mostRecentPointerEvents = [...this.#pressedPointerHistory.values()].map(pointerHistory => pointerHistory[pointerHistory.length-1]);
        let distanceCount = 0;
        let sumOfAllDistancesBetweenPointers = 0;
        let sumOfAllPointerPositions = { x: 0, y: 0 };
        for (let i = 0; i < mostRecentPointerEvents.length; i++) {
          let ev1 = mostRecentPointerEvents[i];
          sumOfAllPointerPositions.x += ev1.x;
          sumOfAllPointerPositions.y += ev1.y;
          for (let j = i+1; j < mostRecentPointerEvents.length; j++) {
            let ev2 = mostRecentPointerEvents[j];
            sumOfAllDistancesBetweenPointers += Math.hypot(ev1.x - ev2.x, ev1.y - ev2.y);
            distanceCount += 1;
          }
        }
        this.#globalPressedPointerStats = {
          centerOfAllPointers: {
            x: sumOfAllPointerPositions.x / this.#pressedPointerHistory.size,
            y: sumOfAllPointerPositions.y / this.#pressedPointerHistory.size,
          },
          sumOfAllDistancesBetweenPointers,
          pointerCount: this.#pressedPointerHistory.size,
        };
      }

      #addEventToPressedPointerHistory(e) {
        // get history array (or create empty one)
        let history = this.#pressedPointerHistory.get(e.pointerId);
        if (history === undefined) {
          history = [];
          this.#pressedPointerHistory.set(e.pointerId, history);
        };

        // prune old events
        const cutoff = e.timeStamp - 50;
        while (history.length > 0 && history[0].time < cutoff) {
          history.shift();
        }

        const cssToDevicePixelRatio = window.devicePixelRatio || 1;
        const ex = e.x * cssToDevicePixelRatio;
        const ey = e.y * cssToDevicePixelRatio;

        let newEvent = {
          x: ex,
          y: ey,
          time: e.timeStamp,
        };
        history.push(newEvent);
        this.#recalculatePressedPointerStats();
        newEvent.globalStateSnapshot = this.#globalPressedPointerStats;
      }

      #appendPinchScaleHistory(scale, scaleFocusX, scaleFocusY, time) {
        this.#pinchScaleHistory.push({scale, screenSpaceScaleFocus: { x: scaleFocusX, y: scaleFocusY }, time});
        const cutoff = time - 50;
        while (this.#pinchScaleHistory.length > 0 && this.#pinchScaleHistory[0].time < cutoff) {
          this.#pinchScaleHistory.shift();
        }
      }

      #pointerDown(e) {
        const cssToDevicePixelRatio = window.devicePixelRatio || 1;
        const ex = e.x * cssToDevicePixelRatio;
        const ey = e.y * cssToDevicePixelRatio;

        // ignore right click
        if (e.pointerType === 'mouse' && e.button === 2) return;

        this.#addEventToPressedPointerHistory(e);
        this.#appendPinchScaleHistory(this.#camera.scale, ex, ey, e.timeStamp);
        this.#canvas.setPointerCapture(e.pointerId);
      }

      #pointerMove(e) {
        // pointer that moved is not pressed (mouse hover)
        if (!this.#pressedPointerHistory.has(e.pointerId)) return;

        const oldCenter = this.#globalPressedPointerStats.centerOfAllPointers;
        const oldDistance = this.#globalPressedPointerStats.sumOfAllDistancesBetweenPointers;

        this.#addEventToPressedPointerHistory(e);

        const newCenter = this.#globalPressedPointerStats.centerOfAllPointers;
        const newDistance = this.#globalPressedPointerStats.sumOfAllDistancesBetweenPointers;

        const oldWorldPos = this.#camera.screenToWorld(oldCenter.x, oldCenter.y, this.#canvas.width, this.#canvas.height);
        const pointerCount = this.#globalPressedPointerStats.pointerCount;
        this.#camera.scale *= (oldDistance === 0) ? 1 : Math.pow(newDistance/oldDistance, pointerCount-1);
        this.#camera.scale = Math.min(Math.max(this.#camera.scale, this.#minScale), this.#maxScale);
        const newWorldPos = this.#camera.screenToWorld(newCenter.x, newCenter.y, this.#canvas.width, this.#canvas.height);
        this.#camera.x += oldWorldPos.x - newWorldPos.x;
        this.#camera.y += oldWorldPos.y - newWorldPos.y;

        this.#appendPinchScaleHistory(this.#camera.scale, newCenter.x, newCenter.y, e.timeStamp);

      }

      #calculatePanVelocity(e) {
        const history = this.#pressedPointerHistory.get(e.pointerId);

        // only look at the events with the maximum pointer count in the history
        // e.g. if there was a pinch, ignore the inevitable single pointer events at the end
        const maxPointerCount = Math.max(...history.map(ev => ev.globalStateSnapshot.pointerCount));
        const filteredHistory = history.filter(ev => ev.globalStateSnapshot.pointerCount === maxPointerCount);

        const firstEvent = filteredHistory[0];
        const lastEvent  = filteredHistory[filteredHistory.length - 1];

        const panDeltaTime = lastEvent.time - firstEvent.time;
        if (panDeltaTime === 0) {
          this.#panVelocity.x = 0;
          this.#panVelocity.y = 0;
        } else {
          this.#panVelocity.x = -this.#camera.screenToWorldDistance((lastEvent.globalStateSnapshot.centerOfAllPointers.x - firstEvent.globalStateSnapshot.centerOfAllPointers.x) / panDeltaTime);
          this.#panVelocity.y = -this.#camera.screenToWorldDistance((lastEvent.globalStateSnapshot.centerOfAllPointers.y - firstEvent.globalStateSnapshot.centerOfAllPointers.y) / panDeltaTime);
        }
      }

      #calculateScaleVelocity() {
        const firstScale = this.#pinchScaleHistory[0];
        const lastScale  = this.#pinchScaleHistory[this.#pinchScaleHistory.length - 1];

        const scaleDeltaTime = lastScale.time - firstScale.time;
        if (scaleDeltaTime === 0) {
          this.#scaleVelocity = 0;
        } else {
          this.#scaleVelocity = Math.log(lastScale.scale / firstScale.scale) / scaleDeltaTime;
          this.#scaleVelocityIsFromPinch = true;
        }
        this.#animatedScaleFocus = firstScale.screenSpaceScaleFocus;
      }

      #pointerUpOrCancel(e) {
        // ignore untracked pointer events
        if (this.#pressedPointerHistory.get(e.pointerId) === undefined) return;

        if (this.#pressedPointerHistory.size === 1) {
          const cssToDevicePixelRatio = window.devicePixelRatio || 1;
          const ex = e.x * cssToDevicePixelRatio;
          const ey = e.y * cssToDevicePixelRatio;

          // scale velocity
          this.#appendPinchScaleHistory(this.#camera.scale, ex, ey, e.timeStamp);
          this.#calculateScaleVelocity();

          if (this.#scaleVelocity === 0) {
            // pan velocity
            this.#addEventToPressedPointerHistory(e);
            this.#calculatePanVelocity(e);
          } else {
            this.#panVelocity.x = 0;
            this.#panVelocity.y = 0;
          }

          // fully released -> fling
          this.#requestAnimation();
        }
        this.#removePointerFromPressedPointerHistory(e.pointerId);
        this.#canvas.releasePointerCapture(e.pointerId);
      }

      #wheel(e) {
        e.preventDefault();
        if (e.deltaY === 0) return;

        const cssToDevicePixelRatio = window.devicePixelRatio || 1;
        const ex = e.x * cssToDevicePixelRatio;
        const ey = e.y * cssToDevicePixelRatio;
        const edeltaY = e.deltaY * cssToDevicePixelRatio;

        let scaleFactor;
        if (e.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          scaleFactor = Math.pow(1.1, -edeltaY/120);
        } else {
          scaleFactor = (edeltaY > 0 ? 1/1.1 : 1.1);
        }

        const scaleVelocityChange = -edeltaY/40000;
        if (Math.sign(this.#scaleVelocity) !== Math.sign(scaleVelocityChange)) {
          this.#scaleVelocity = 0;
        }
        this.#scaleVelocity += scaleVelocityChange;
        this.#scaleVelocityIsFromPinch = false;
        this.#animatedScaleFocus.x = ex;
        this.#animatedScaleFocus.y = ey;

        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;

        this.#requestAnimation();
      }

      #requestAnimation() {
        if (this.#animationRequested) return;
        window.requestAnimationFrame((t) => {
          this.#animationRequested = false;
          let dt = 16.6;
          if (this.#previousFrameTimeStamp !== null) {
            dt = Math.min(t - this.#previousFrameTimeStamp, 100);
          }
          this.#previousFrameTimeStamp = t;
          this.#animate(dt);
        });
        this.#animationRequested = true;
      }

      #animate(dt) {
        if (this.#pressedPointerHistory.size === 0) {

          this.#camera.x += this.#panVelocity.x * dt;
          this.#camera.y += this.#panVelocity.y * dt;
          this.#panVelocity.x *= .95;
          this.#panVelocity.y *= .95;

          const targetWorldPos = this.#camera.screenToWorld(this.#animatedScaleFocus.x, this.#animatedScaleFocus.y, this.#canvas.width, this.#canvas.height);
          this.#camera.scale *= Math.exp(this.#scaleVelocity * dt);
          this.#camera.scale = Math.min(Math.max(this.#camera.scale, this.#minScale), this.#maxScale);
          const scaledWorldPos = this.#camera.screenToWorld(this.#animatedScaleFocus.x, this.#animatedScaleFocus.y, this.#canvas.width, this.#canvas.height);
          this.#camera.x += targetWorldPos.x - scaledWorldPos.x;
          this.#camera.y += targetWorldPos.y - scaledWorldPos.y;
          if (this.#scaleVelocityIsFromPinch) {
            this.#scaleVelocity *= .9;
          } else {
            this.#scaleVelocity *= .8;
          }

          if (Math.abs(this.#scaleVelocity) > .0001 || this.#camera.worldToScreenDistance(Math.hypot(this.#panVelocity.x, this.#panVelocity.y)) > .01) {
            this.#requestAnimation();
            return;
          }
        }
        this.#previousFrameTimeStamp = null;
        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;
        this.#scaleVelocity = 0;
      }
    }



    // ========== LAYERS ==========
    const TILE_SIZE = 512;
    class MapLayer {
      // create MapLayer's
      static async fromPath(path, onTile) {
        if (path.endsWith('.png')) {
          const res = await fetch(path);
          const blob = await res.blob();
          const image = await createImageBitmap(blob);
          const fileName = path.substring(path.lastIndexOf('/') + 1);
          return await MapLayer.fromImage(image, onTile, fileName);
        }
        // fetch lod file list
        const tileListPath = `${path}/tile_list.txt`;
        const tileListResponse = await fetch(tileListPath);
        if (!tileListResponse.ok) {
          throw new Error(`failed to fetch tile list from ${tileListPath}: ${tileListResponse.status} ${tileListResponse.statusText}`);
        }
        const tileList = new Set((await tileListResponse.text()).split('\n'));

        const mapLayer = new MapLayer((lod, x, y) => MapLayer.#fetchTileFromPath(lod, x, y, path, tileList), onTile);

        // fetch metadata
        const metadataPath = `${path}/metadata.json`;
        const matadataResponse = await fetch(metadataPath);
        if (!matadataResponse.ok) {
          throw new Error(`failed to fetch map metadata from ${metadataPath}: ${matadataResponse.status} ${matadataResponse.statusText}`);
        }
        try {
          mapLayer.metadata = JSON.parse(await matadataResponse.text());
          mapLayer.metadata.maxLod = mapLayer.metadata.maxLod || 0;
          mapLayer.metadata.scale = mapLayer.metadata.scale || 1;
        } catch (parseError) {
          throw new Error(`could not parse map metadata from ${metadataPath}: ${parseError.message}`);
        }

        return mapLayer;
      }

      static async fromImage(image, onTile, fileName = '') {
        const matchesX     = [...fileName.matchAll(/x(-?\d+(?:\.\d+)?)/g)];
        const matchesZ     = [...fileName.matchAll(/z(-?\d+(?:\.\d+)?)/g)];
        const matchesScale = [...fileName.matchAll(/scale(-?\d+(?:\.\d+)?)/g)];

        const topLeftX = (matchesX    .length > 0) ? parseFloat(matchesX    .at(-1)[1]) : 0;
        const topLeftY = (matchesZ    .length > 0) ? parseFloat(matchesZ    .at(-1)[1]) : 0;
        const scale    = (matchesScale.length > 0) ? parseFloat(matchesScale.at(-1)[1]) : 1;

        const mapLayer = new MapLayer(
          (lod, x, y) => MapLayer.#createTileFromImage(lod, x, y, image, topLeftX, topLeftY),
          onTile
        );
        mapLayer.metadata = {
          width: image.width,
          height: image.height,
          topLeft: {
            x: topLeftX,
            y: topLeftY,
          },
          maxLod: 0,
          scale: scale,
        };
        return mapLayer;
      }

      fitCamera(camera, canvas) {
        const screenWidth  = this.metadata.width  * this.metadata.scale;
        const screenHeight = this.metadata.height * this.metadata.scale;
        const scaleX = canvas.width  / (screenWidth  /* * 1.1 */);
        const scaleY = canvas.height / (screenHeight /* * 1.1 */);
        camera.scale = Math.min(scaleX, scaleY);
        camera.x = this.metadata.topLeft.x * this.metadata.scale + screenWidth  / 2;
        camera.y = this.metadata.topLeft.y * this.metadata.scale + screenHeight / 2;
      }

      // obtain tiles
      static async #fetchTileFromPath(lod, x, y, path, tileList) {
        const fileName = `lod${lod}_x${x}_z${y}.png`;
        if (!tileList.has(fileName)) return null;

        if (DEBUG_TILE_FETCH_DELAY) {
          await new Promise(r => setTimeout(r, Math.floor(Math.random() * 1000) + 1000));
        }

        const res = await fetch(`${path}/${fileName}`);
        if (res.status === 404) return null;
        if (!res.ok) throw new Error(`failed to fetch lod: ${res.status}`);
        const blob = await res.blob();
        return await createImageBitmap(blob);
      }

      static async #createTileFromImage(lod, x, y, image, topLeftX, topLeftY) {
        const tileSize = TILE_SIZE * Math.pow(2, lod);
        //const offsetX = 3453 - 7578 + 317 - x * tileSize;
        //const offsetY = 1213 - 3746 +  21 - y * tileSize;
        const offsetX = topLeftX - x * tileSize;
        const offsetY = topLeftY - y * tileSize;

        // requested tile is outside of image
        if (offsetX < -image.width || offsetY < -image.height) return null;
        if (offsetX > tileSize || offsetY > tileSize) return null;

        if (DEBUG_TILE_FETCH_DELAY) {
          await new Promise(r => setTimeout(r, Math.floor(Math.random() * 1000) + 1000));
        }

        const osc = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
        const ctx = osc.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.clearRect(0, 0, osc.width, osc.height);
        ctx.drawImage(image, -offsetX, -offsetY, tileSize, tileSize, 0, 0, osc.width, osc.height);
        const data = ctx.getImageData(0, 0, osc.width, osc.height).data;

        // skip fully transparent tiles
        for (let i = 3; i < data.length; i += 4) {
          if (data[i] !== 0) {
            return osc.transferToImageBitmap();
          }
        }
        return null;
      }



      #fetchTile;
      #onTile;

      metadata;

      #maxConcurrentFetches = 6;
      #tiles = new Map();
      #inflightTileKeys = new Set();
      #nonExistentTiles = new Set();
      #queue = null;

      constructor(fetchTile, onTile) {
        this.#fetchTile = fetchTile;
        this.#onTile = onTile;
        Object.seal(this);
      }

      async exportLods() {
        const metadataBlob = new Blob([JSON.stringify(this.metadata)], { type: "application/json" });
        const blobs = [{ name: 'metadata.json', blob: metadataBlob }];

        let lodFileNames = [];

        const canvas = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
        const ctx = canvas.getContext("2d");
        for (const [key, tile] of this.#tiles.entries()) {
          const { x, y, lod } = this.#unpackKey(key);
          const name = `lod${lod}_x${x}_z${y}.png`;
          lodFileNames.push(name);
          console.log(name);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(tile, 0, 0);
          blobs.push({ name, blob: await canvas.convertToBlob() });
        }

        let lodFileNamesBlob = new Blob([lodFileNames.sort().join('\n')], { type: 'text/plain' });
        blobs.push({ name: 'tile_list.txt', blob: lodFileNamesBlob });

        return blobs;
      }

      calculateLod(camera) {
        return Math.max(0, Math.floor(-Math.log(camera.scale * this.metadata.scale)/Math.log(2)));
      }

      calculateScreenSpaceTileSize(lod) {
        return TILE_SIZE * Math.pow(2, lod) * this.metadata.scale;
      }

      // assumes camera.apply() has been called already
      draw(canvasContext, camera) {
        const canvasWorldWidth = camera.screenToWorldDistance(canvasContext.canvas.width, true);
        const canvasWorldHeight = camera.screenToWorldDistance(canvasContext.canvas.height, true);

        const lod = this.calculateLod(camera);
        const screenSpaceTileSize = this.calculateScreenSpaceTileSize(lod);

        const minTileX = Math.floor((camera.x - canvasWorldWidth  / 2) / screenSpaceTileSize);
        const minTileY = Math.floor((camera.y - canvasWorldHeight / 2) / screenSpaceTileSize);
        const maxTileX = Math.floor((camera.x + canvasWorldWidth  / 2) / screenSpaceTileSize);
        const maxTileY = Math.floor((camera.y + canvasWorldHeight / 2) / screenSpaceTileSize);

        for (let tileX = minTileX; tileX <= maxTileX; tileX++) {
          for (let tileY = minTileY; tileY <= maxTileY; tileY++) {
            let image = undefined;
            let lodOffset = 0;
            let lodOffsetPow;
            while (lodOffset < 4) {
              lodOffsetPow = Math.pow(2, lodOffset);
              image = this.#tiles.get(this.#tileKey(Math.floor(tileX/lodOffsetPow), Math.floor(tileY/lodOffsetPow), lod  + lodOffset));
              if (image !== undefined) break;
              lodOffset += 1;
            }
            if (image === undefined) continue;
            const fromX = ((tileX % lodOffsetPow) + lodOffsetPow) % lodOffsetPow / lodOffsetPow * image.width;
            const fromY = ((tileY % lodOffsetPow) + lodOffsetPow) % lodOffsetPow / lodOffsetPow * image.height;
            canvasContext.drawImage(
              image,
              fromX,
              fromY,
              image.width / lodOffsetPow,
              image.height / lodOffsetPow,
              tileX * screenSpaceTileSize,
              tileY * screenSpaceTileSize,
              screenSpaceTileSize,
              screenSpaceTileSize
            );
          }
        }

        const centerTileX = Math.floor(camera.x / screenSpaceTileSize);
        const centerTileY = Math.floor(camera.y / screenSpaceTileSize);

        const thisLayer = this;
        this.#queue =
          (function* (lod, centerTileX, centerTileY, minTileX, minTileY, maxTileX, maxTileY, maxLod, minLod) {
            maxLod = Math.max(maxLod, lod);
            minLod = Math.min(minLod, lod);
            for (let lodOffset = maxLod - lod; lod + lodOffset >= minLod; lodOffset--) {
              const offsetLod = lod + lodOffset;
              const pow = Math.pow(2, -lodOffset);
              const pattern = boundedDiamondPattern(
                Math.floor(centerTileX * pow),
                Math.floor(centerTileY * pow),
                Math.floor(minTileX * pow),
                Math.floor(minTileY * pow),
                Math.floor(maxTileX * pow),
                Math.floor(maxTileY * pow),
              );
              for (const { x, y } of pattern) {
                yield { x, y, lod: offsetLod };
              }
            }
            if (DEBUG_PREFETCH_LODS) {
              const activeLayer = layers.at(activeLayerIndex);
              if (thisLayer === activeLayer) {
                console.log('end of lod queue reached for active layer');
              } else {
                console.log('end of lod queue reached for a background layer');
              }
            }
          })(lod, centerTileX, centerTileY, minTileX, minTileY, maxTileX, maxTileY, this.metadata?.maxLod || lod, DEBUG_PREFETCH_LODS ? 0 : lod)
          .map( ({x, y, lod }) => ({x, y, lod, key: this.#tileKey(x, y, lod)}) )
          .filter( ({x, y, lod, key}) => !this.#tiles           .has(key) )
          .filter( ({x, y, lod, key}) => !this.#inflightTileKeys.has(key) )
          .filter( ({x, y, lod, key}) => !this.#nonExistentTiles.has(key) );

        this.#triggerFetches();
      }

      #triggerFetches() {
        if (DEBUG_STOP_TILE_FETCH) return;
        while (this.#inflightTileKeys.size < this.#maxConcurrentFetches) {
          const tile = this.#queue.next().value;
          if (tile === undefined) return;
          this.#inflightTileKeys.add(tile.key);
          this.#fetchTile(tile.lod, tile.x, tile.y)
            .then(image => {
              if (image === null) {
                this.#nonExistentTiles.add(tile.key)
              } else {
                this.#tiles.set(tile.key, image);
                this.metadata.maxLod = Math.max(this.metadata.maxLod, tile.lod);
                this.#onTile();
              }
            })
            .catch(error => {
              // TODO
            })
            .finally(() => {
              this.#inflightTileKeys.delete(tile.key);
              this.#triggerFetches();
            });
        }
      }

      #tileKey(x, y, lod) {
        return (x + 0x800000) * (1 << 28) + (y + 0x800000) * (1 << 4) + lod;
      }

      #unpackKey(key) {
        const lod = key & 0xF;
        const y   = ((key >> 4) & 0xFFFFFF) - 0x800000;
        const x   = Math.floor(key / (1 << 28)) - 0x800000;
        return { x, y, lod };
      }
    }



    // ========== MARKERS ==========
    function drawMarker(marker, ctx, camera, onRedrawNeeded) {
      drawMarker.icons = drawMarker.icons || new Map();
      const icons = drawMarker.icons;

      const posX = marker.x || 0;
      const posY = marker.z || 0;

      const cssToDevicePixelRatio = window.devicePixelRatio || 1;
      const screenPos = camera.worldToScreen(posX + .5, posY + .5, ctx.canvas.width, ctx.canvas.height, true);

      if (marker.text) {
        const textSizeMap         = marker.textSizeMap             || 95;
        const textSizeScreen      = marker.textSizeScreen          || textSizeMap / 2;
        ctx.textAlign             = marker.textAlign               || 'center';
        ctx.textBaseline          = marker.textBaseline            || 'middle';
        ctx.strokeStyle           = marker.textStrokeStyle         || '#000';
        ctx.fillStyle             = marker.textFillStyle           || '#f00';
        const lineWidthPercentage = marker.textLineWidthPercentage || .075;

        const textSize = Math.min(textSizeMap * camera.quantizedScale(), textSizeScreen * cssToDevicePixelRatio);
        ctx.font = `${textSize}px MinecraftItalic`;
        // * 2 because half of strokeText() is overdrawn by fillText()
        ctx.lineWidth = lineWidthPercentage * 2 * textSize;

        ctx.strokeText(marker.text, screenPos.x, screenPos.y);
        ctx.fillText(marker.text, screenPos.x, screenPos.y);
      } else if (marker.iconPath) {
        const icon = icons.get(marker.iconPath);
        if (icon === undefined) {
          fetch(marker.iconPath)
            .then(response => {
              if (response.status === 404) icons.set(marker.iconPath, null);
              else if (!response.ok) throw new Error(`failed to fetch icon: ${res.status}`);
              else return response.blob();
            })
            .then(blob => createImageBitmap(blob))
            .then(image => {
              icons.set(marker.iconPath, image);
              onRedrawNeeded();
            })
            .catch(err => {
              // TODO
            });
        } else if (marker !== null) {
          const iconScaleMap    = marker.iconScaleMap    || 6;
          const iconScaleScreen = marker.iconScaleScreen || iconScaleMap / 2;
          const iconScale = Math.min(iconScaleMap * camera.quantizedScale(), iconScaleScreen * cssToDevicePixelRatio);
          ctx.drawImage(icon, screenPos.x - icon.width/2 * iconScale, screenPos.y - icon.height/2 * iconScale, icon.width * iconScale, icon.height * iconScale);
        }
      }
    }



    // ========== GLOBALS ==========
    let DEBUG_STOP_TILE_FETCH = false;
    let DEBUG_TILE_FETCH_DELAY = false;
    let DEBUG_PREFETCH_LODS = false;

    const mainCanvas = document.getElementById('main-canvas');
    const hudX = document.getElementById('hud-x');
    const hudZ = document.getElementById('hud-z');

    const mainCanvasContext = mainCanvas.getContext('2d');
    const mainCamera = new Camera();
    const cameraPanZoomController = new PanZoomController(mainCamera, mainCanvas);

    let activeLayerIndex = 0;
    let layers = [];

    let animationFrameRequested = false;

    let clickedWorldCoords = null;

    let showMarkers = false;
    let markers = [
      { x:   -62, z:   708, y: 123, iconPath: '/icons/coal.png'         },
      { x:  2784, z:  -376, y: 125, iconPath: '/icons/redstone.png'     },
      { x:   946, z:  -374, y: 142, iconPath: '/icons/coal.png'         },
      { x:   615, z:  -781, y:  98, iconPath: '/icons/diamond.png'      },
      { x:  2433, z:  -661, y:  82, iconPath: '/icons/diamond.png'      },
      { x:   958, z:   995, y:  92, iconPath: '/icons/gold_ingot.png'   },
      { x:   896, z:  -356, y: 142, iconPath: '/icons/gold_ingot.png'   },
      { x:  2738, z:   647, y:  78, iconPath: '/icons/iron_ingot.png'   },
      { x:  1657, z:  -287, y:  69, iconPath: '/icons/iron_ingot.png'   },
      { x:  1380, z:   630, y: 139, iconPath: '/icons/iron_ingot.png'   },
      { x:  1478, z: -1467, y: 137, iconPath: '/icons/lapis_lazuli.png' },
      { x:  -114, z:  1150, y: 120, iconPath: '/icons/lapis_lazuli.png' },
      { x:  -558, z:   173, y:  74, iconPath: '/icons/redstone.png'     },
      { x:  -528, z:  -531, y: 110, iconPath: '/icons/lapis_lazuli.png' },
      { x: -1408, z:  -781, y: 212, iconPath: '/icons/coal.png'         },
      { x: -1794, z:  -163, y: 132, iconPath: '/icons/iron_ingot.png'   },
      { x: -1269, z:   -51, y:  83, iconPath: '/icons/copper_ingot.png' },
      { x: -1532, z:   700, y: 120, iconPath: '/icons/iron_ingot.png'   },
      { x: -1509, z:   882, y: 108, iconPath: '/icons/coal.png'         },
      { x: -1558, z:   854, y: 106, iconPath: '/icons/iron_ingot.png'   },
      { x: -2012, z:   901, y: 101, iconPath: '/icons/diamond.png'      },
      { x: -2855, z:   981, y: 116, iconPath: '/icons/coal.png'         },
      { x: -2798, z:  -673, y: 114, iconPath: '/icons/coal.png'         },
      { x: -2939, z:  -858, y:  92, iconPath: '/icons/iron_ingot.png'   },
      { x:  -414, z:  1594, y: 111, iconPath: '/icons/redstone.png'     },
      { x:  -324, z:   690, y: 107, iconPath: '/icons/coal.png'         },
      { x:  -324, z:   686, y: 110, iconPath: '/icons/iron_ingot.png'   },
      { x:  -482, z: -1096, y:  88, iconPath: '/icons/iron_ingot.png'   },
      { x:  1436, z:  1618, y:  79, iconPath: '/icons/diamond.png'      },
      { x:  2930, z:  1069, y: 125, iconPath: '/icons/coal.png'         },
      { x:  1725, z:   825, y: 116, iconPath: '/icons/coal.png'         },
      { x:  2019, z:   188, y:  83, iconPath: '/icons/coal.png'         },
      { x: -1873, z:  -305, y: 164, iconPath: '/icons/quartz.png'       },
      { x: -1265, z:   673, y:  70, iconPath: '/icons/gold_ingot.png'   },
      { x: -2717, z:   559, y: 106, iconPath: '/icons/copper_ingot.png' },
      { x:  1554, z: -1130, y:  15, iconPath: '/icons/lava_bucket.png'  },

      { x:  -996, z:  -773, textFillStyle: '#26a38c', textSizeMap: 100, text: 'USGS'                      },
      { x:  3049, z:  1277, textFillStyle: '#56935b', textSizeMap: 100, text: 'Harvestspire'              },
      { x:  -113, z: -1342, textFillStyle: '#43a6d9', textSizeMap: 100, text: 'Pantha'                    },
      { x:  1583, z: -1323, textFillStyle: '#8667de', textSizeMap: 100, text: 'Penguinia'                 },
      { x:  2275, z:  -410, textFillStyle: '#f35e0e', textSizeMap:  65, text: 'Oranjestad'                },
      { x:  2492, z:  -310, textFillStyle: '#8be6f0', textSizeMap:  65, text: 'Ironhill'                  },
      { x:  2951, z:  -832, textFillStyle: '#ffff00', textSizeMap:  65, text: 'Pebbleopolis'              },
      { x:   755, z:  1181, textFillStyle: '#cefc64', textSizeMap:  45, text: 'Prinzenburg'               },
      { x:   272, z:    83, textFillStyle: '#649cce', textSizeMap:  45, text: 'Aeterna Island'            },
      { x:  2091, z:   -64, textFillStyle: '#52844f', textSizeMap:  45, text: 'Hidden Leaf'               },
      { x:  -642, z: -1010, textFillStyle: '#9587d3', textSizeMap:  45, text: 'Eluphenia'                 },
      { x: -2087, z:   585, textFillStyle: '#6b4f8e', textSizeMap:  45, text: 'Viking Island'             },

      { x:  1722, z:  -416, textFillStyle: '#6767ea', textSizeMap: 100, text: 'Polestar'                  },

      { x:  1496, z:   -43, textFillStyle: '#de942c', textSizeMap:  65, text: 'T.E.A. Alliance'           },

      { x:  -456, z:  1504, textFillStyle: '#e1aa37', textSizeMap:  65, text: 'Golden Prosperity'         },
      { x:  -409, z:  1586, textFillStyle: '#e1aa37', textSizeMap:  45, text: 'Big Stump'                 },

      { x:    60, z:  1556, textFillStyle: '#559b16', textSizeMap:  65, text: 'The SWTZ'                  },
      { x:   -14, z:  1632, textFillStyle: '#559b16', textSizeMap:  45, text: 'Bastion'                   },

      { x:   160, z:  1735, textFillStyle: '#c1ff0b', textSizeMap:  65, text: 'Slobland'                  },

      { x: -2764, z: -1130, textFillStyle: '#ec67cc', textSizeMap: 100, text: 'Nation of the People'      },
      { x: -3052, z:  -989, textFillStyle: '#ec67cc', textSizeMap:  65, text: 'Havenstead'                },
      { x: -2981, z:  -807, textFillStyle: '#ec67cc', textSizeMap:  65, text: 'Thornspire'                },
      { x: -2446, z:  -511, textFillStyle: '#ec67cc', textSizeMap:  65, text: 'Midas Village'             },
      { x: -3202, z:  -606, textFillStyle: '#ec67cc', textSizeMap:  65, text: 'TASC Island'               },
      { x: -2539, z:  -855, textFillStyle: '#ec67cc', textSizeMap:  65, text: 'Scyllanthos'               },

      { x: -2938, z:  -483, textFillStyle: '#d1502f', textSizeMap: 100, text: 'Soup Bowl'                 },

      { x: -3120, z:   561, textFillStyle: '#4b8dae', textSizeMap: 100, text: 'Rainveil'                  },
      { x: -3057, z:   422, textFillStyle: '#4b8dae', textSizeMap:  65, text: 'Viracocha Port'            },

      { x: -1387, z:  -949, textFillStyle: '#bbdc65', textSizeMap: 100, text: 'Helioria'                  },
      { x: -1412, z: -1215, textFillStyle: '#bbdc65', textSizeMap:  65, text: 'Solaris'                   },

      { x: -2988, z:   858, textFillStyle: '#32ed22', textSizeMap: 100, text: 'El Gran Cartel'            },
      { x: -2388, z:   659, textFillStyle: '#32ed22', textSizeMap:  45, text: 'Zanco Ciudad'              },
      { x: -2665, z:   739, textFillStyle: '#32ed22', textSizeMap:  65, text: 'La Mejora'                 },

      { x:  -330, z: -1020, textFillStyle: '#ffff00', textSizeMap:  65, text: 'Velmora'                   },
      { x:  -441, z:  -961, textFillStyle: '#ffff00', textSizeMap:  45, text: 'Tower of Wealth'           },

      { x:  2553, z: -1452, textFillStyle: '#fe3333', textSizeMap: 100, text: 'Northelios'                },
      { x:  2415, z: -1329, textFillStyle: '#fe3333', textSizeMap:  65, text: 'Snowlandia'                },

      { x:  2268, z:  -751, textFillStyle: '#f300f3', textSizeMap: 100, text: 'Renkai'                    },
      { x:  2409, z: -1033, textFillStyle: '#f300f3', textSizeMap:  65, text: 'Kokai'                     },
      { x:  2429, z:  -553, textFillStyle: '#f300f3', textSizeMap:  65, text: 'Hoseki'                    },

      { x:  2683, z:   452, textFillStyle: '#de8644', textSizeMap: 100, text: 'Imperium'                  },
      { x:  2865, z:   319, textFillStyle: '#de8644', textSizeMap:  65, text: 'Sideris'                   },
      { x:  2757, z:   613, textFillStyle: '#de8644', textSizeMap:  65, text: 'Se Lang Mur'               },

      { x:  2693, z:   989, textFillStyle: '#fffa96', textSizeMap: 100, text: 'Universale'                },
      { x:  2511, z:  1111, textFillStyle: '#fffa96', textSizeMap:  65, text: 'Venican'                   },

      { x:  1650, z:  1043, textFillStyle: '#b9bbcc', textSizeMap: 100, text: 'Checkerboard Union'        },
      { x:  1587, z:   308, textFillStyle: '#b9bbcc', textSizeMap:  65, text: 'Steej'                     },
      { x:  1277, z:   570, textFillStyle: '#b9bbcc', textSizeMap:  65, text: 'The Great Wall'            },
      { x:  1141, z:   411, textFillStyle: '#b9bbcc', textSizeMap:  45, text: 'Wallachia'                 },
      { x:  1563, z:   689, textFillStyle: '#b9bbcc', textSizeMap:  65, text: 'House of Cards'            },

      { x:   800, z:    96, textFillStyle: '#f90120', textSizeMap: 100, text: 'Sarkovia'                  },
      { x:   867, z:   283, textFillStyle: '#f90120', textSizeMap:  65, text: 'Metalgrad'                 },
      { x:   986, z:  -167, textFillStyle: '#f90120', textSizeMap:  65, text: 'Krasnygrad'                },
      { x:   858, z:  -478, textFillStyle: '#f90120', textSizeMap:  65, text: 'Flussdorf'                 },
      { x:  1286, z:  -322, textFillStyle: '#f90120', textSizeMap:  65, text: 'Rotstadt'                  },

      { x:   615, z:  -792, textFillStyle: '#0868a4', textSizeMap:  45, text: 'Fallen Temple of the Node' },

      { x:  -505, z:   515, textFillStyle: '#edc600', textSizeMap: 100, text: 'Kingdom of Chimera'        },
      { x: -2210, z:  1023, textFillStyle: '#edc600', textSizeMap:  65, text: 'White Harbour'             },
      { x: -1730, z:   734, textFillStyle: '#edc600', textSizeMap:  65, text: 'Heraclesia'                },
      { x: -1448, z:   523, textFillStyle: '#edc600', textSizeMap:  65, text: 'Aramore'                   },
      { x: -1500, z:   400, textFillStyle: '#edc600', textSizeMap:  45, text: 'Toprock'                   },
      { x: -1840, z:   177, textFillStyle: '#edc600', textSizeMap:  65, text: 'Northport'                 },
      { x:  -432, z:   710, textFillStyle: '#edc600', textSizeMap:  65, text: 'Wolframstein'              },
      { x:  -566, z:   247, textFillStyle: '#edc600', textSizeMap:  65, text: 'Saorsa'                    },
      { x:  -129, z:   300, textFillStyle: '#edc600', textSizeMap:  65, text: 'Colodore Order'            },
      { x:  -181, z:  -285, textFillStyle: '#edc600', textSizeMap:  65, text: 'Horizon'                   },
    ];

    document.addEventListener('keydown', e => {
      if (e.code === 'Tab') {
        e.preventDefault();
        let textbox = document.getElementById('textbox').hidden = true;
        showMarkers = !showMarkers;
        requestRender();
      } else if (e.code === 'Space') {
        const activeLayer = layers.at(activeLayerIndex);
        cameraPanZoomController.stop();
        activeLayer.fitCamera(mainCamera, mainCanvas);
      } else if ('0' <= e.key && e.key <= '9') {
        const newIndex = e.key - 1; // coerce digit to number by subtracting
        if (activeLayerIndex !== newIndex) {
          activeLayerIndex = newIndex;
          requestRender();
        }
      }
    });



    // ========== COORDS  ==========
    mainCanvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      const cssToDevicePixelRatio = window.devicePixelRatio || 1;
      const ex = e.x * cssToDevicePixelRatio;
      const ey = e.y * cssToDevicePixelRatio;
      let newClickedWorldCoords = mainCamera.screenToWorld(ex, ey, mainCanvas.width, mainCanvas.height, true);
      newClickedWorldCoords.x = Math.floor(newClickedWorldCoords.x);
      newClickedWorldCoords.y = Math.floor(newClickedWorldCoords.y);
      if (clickedWorldCoords != null && newClickedWorldCoords.x === clickedWorldCoords.x && newClickedWorldCoords.y === clickedWorldCoords.y) {
        clickedWorldCoords = null;
        window.history.replaceState({}, '', `${window.location.pathname}`);
        hudX.style.display = 'none';
        hudZ.style.display = 'none';
      } else {
        clickedWorldCoords = newClickedWorldCoords;
        window.history.replaceState({}, '', `${window.location.pathname}?${clickedWorldCoords.x},${clickedWorldCoords.y}`);
        hudX.textContent = clickedWorldCoords.x;
        hudZ.textContent = clickedWorldCoords.y;
        hudX.style.display = 'block';
        hudZ.style.display = 'block';
      }
      requestRender();
    });



    // ========== RENDER ==========
    mainCamera.addChangeCallback(() => { requestRender(); });

    function requestRender() {
      if (animationFrameRequested) return;
      window.requestAnimationFrame((t) => {
        animationFrameRequested = false;
        render(mainCanvasContext, mainCamera);
      });
      animationFrameRequested = true;
    }

    function render(ctx, camera) {
      ctx.resetTransform();
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.imageSmoothingEnabled = false;//camera.scale < 1;

      const activeLayer = layers.at(activeLayerIndex);
      if (activeLayer) {

        // quantize camera scale to hide tile seams
        const lod = activeLayer.calculateLod(camera);
        const tileSize = activeLayer.calculateScreenSpaceTileSize(lod);
        camera.scaleQuantizationSize = tileSize;
        camera.apply(ctx, true);
        activeLayer.draw(ctx, camera);
      }

      ctx.resetTransform();

      if (showMarkers) {
        ctx.fillStyle = '#0005';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        for (const marker of markers) {
          drawMarker(marker, ctx, camera, () => requestRender());
        }
      }

      if (clickedWorldCoords !== null) {
        let screenCoords = camera.worldToScreen(clickedWorldCoords.x + .5, clickedWorldCoords.y + .5, mainCanvas.width, mainCanvas.height, true);
        drawPin(ctx, screenCoords.x, screenCoords.y);
      }

    }

    function drawPin(ctx, x, y, color = '#F00') {
      const pinWidth = 32;
      const pinHeight = 26;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - pinWidth/2, y - pinHeight);
      ctx.lineTo(x + pinWidth/2, y - pinHeight);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }



    // ========== TOOLING ==========
    // downloadZip([{ name, blob }, ...], "archive.zip")
    async function downloadZip(files, zipName = 'archive.zip') {
      const te = new TextEncoder();
      const u16 = v => new Uint8Array([v & 255, v >> 8 & 255]);
      const u32 = v => new Uint8Array([v & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255]);

      // CRC32 table + fn
      const TABLE = (() => {
        const t = new Uint32Array(256);
        for (let i = 0; i < 256; i++) { let c = i; for (let k = 0; k < 8; k++) c = c & 1 ? 0xEDB88320 ^ (c >>> 1) : c >>> 1; t[i] = c >>> 0; }
        return t;
      })();
      const crc32 = bytes => { let c = ~0; for (let b of bytes) c = TABLE[(c ^ b) & 255] ^ (c >>> 8); return (c ^ -1) >>> 0; };

      const body = [], central = [];
      let offset = 0;

      for (let i = 0; i < files.length; i++) {
        const name = te.encode(files[i].name || `file${i}`);
        const data = new Uint8Array(await files[i].blob.arrayBuffer());
        const crc = crc32(data), size = data.length, localOffset = offset;

        // --- local file header ---
        body.push(
          u32(0x04034b50),   // local sig
          u16(20),           // version
          u16(0x0800),       // flags (UTF-8)
          u16(0),            // method (0 = store)
          u16(0), u16(0),    // time/date
          u32(crc),          // crc32
          u32(size),         // comp size
          u32(size),         // uncomp size
          u16(name.length),  // name len
          u16(0),            // extra len
          name,              // filename
          data               // file data
        );
        offset += 30 + name.length + size;

        // --- central directory entry ---
        central.push(
          u32(0x02014b50),   // central sig
          u16(20), u16(20),  // version made/needed
          u16(0x0800),       // flags (UTF-8)
          u16(0),            // method
          u16(0), u16(0),    // time/date
          u32(crc),
          u32(size), u32(size),
          u16(name.length),
          u16(0), u16(0),    // extra/comment len
          u16(0), u16(0),    // disk/internal attrs
          u32(0),            // external attrs
          u32(localOffset),  // local header offset
          name
        );
      }

      const centralSize = central.reduce((n, b) => n + b.length, 0);
      const centralStart = offset;

      // --- end of central dir ---
      const end = [
        u32(0x06054b50), // end sig
        u16(0), u16(0),  // disk nums
        u16(files.length), u16(files.length), // counts
        u32(centralSize),
        u32(centralStart),
        u16(0)           // comment len
      ];

      // zip blob
      const zipBlob = new Blob([...body, ...central, ...end], { type: "application/zip" });

      // trigger download
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = zipName;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function downloadLods() {
      const activeLayer = layers.at(activeLayerIndex);
      if (activeLayer) {
        downloadZip(await activeLayer.exportLods());
      }
    }



    // ========== EVENTS ==========
    window.addEventListener('paste', async e => {
      console.log('paste event:', e);
      const file = e.clipboardData.items[0].getAsFile();
      if (file === null) return;
      const bitmap = await createImageBitmap(file);
      if (bitmap === null) return;
      const layer = await MapLayer.fromImage(bitmap, () => { requestRender(); } );
      console.log(layer);
      layers.push(layer);
    });

    window.addEventListener('resize', () => {
      const cssToDevicePixelRatio = window.devicePixelRatio || 1;
      let screenWidthInCssPixels = window.visualViewport?.width || window.innerWidth;
      let screenHeightInCssPixels = window.visualViewport?.height || window.innerHeight;
      mainCanvas.width = Math.round(screenWidthInCssPixels * cssToDevicePixelRatio);
      mainCanvas.height = Math.round(screenHeightInCssPixels * cssToDevicePixelRatio);
      requestRender();
    });

    (async () => {
      window.dispatchEvent(new Event('resize'));
      await document.fonts.load('32px MinecraftItalic');

      const mainLayer = await MapLayer.fromPath( 'mapdata/zders_2025-09-15_08.48.25', () => { requestRender(); } );
      cameraPanZoomController.stop();
      mainLayer.fitCamera(mainCamera, mainCanvas);
      layers.push(mainLayer);

      document.getElementById('loading').remove();
      let urlCoords = window.location.search.slice(1).split(',').map(Number);
      if (urlCoords.length == 2 && !Number.isNaN(urlCoords[0]) && !Number.isNaN(urlCoords[1])) {
        clickedWorldCoords = { x: Math.floor(urlCoords[0]), y: Math.floor(urlCoords[1]) };
        window.history.replaceState({}, '', `${window.location.pathname}?${clickedWorldCoords.x},${clickedWorldCoords.y}`);
        hudX.textContent = clickedWorldCoords.x;
        hudZ.textContent = clickedWorldCoords.y;
        hudX.style.display = 'block';
        hudZ.style.display = 'block';
      } else {
        window.history.replaceState({}, '', `${window.location.pathname}`);
      }
      window.setTimeout(() => { document.getElementById('textbox').hidden = true; }, 5000);
      requestRender();

      layers.push(await MapLayer.fromPath( 'mapdata/zders_night_2025-09-15_23.56.48', () => { requestRender(); } ));
      layers.push(await MapLayer.fromPath( 'mapdata/usgs_day12_v2', () => { requestRender(); } ));
      layers.push(await MapLayer.fromPath( 'mapdata/edi_day11_v1', () => { requestRender(); } ));
      layers.push(await MapLayer.fromPath( 'mapdata/zders_ore_waypoints', () => { requestRender(); } ));
    })();
  </script>
</body>
</html>
