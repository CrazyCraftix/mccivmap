<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,">
  <title>mccivmap</title>
  <style>
    body { margin: 0; background: #000; color: #fff; font: 14px system-ui; }
    #main-canvas { position: fixed; inset: 0; touch-action: none; }
    #hud-x,#hud-z { display: none; background: #0008; position: fixed; top: 12px; padding: .3rem .6rem; border-radius: .4rem; pointer-events: none; font-variant-numeric: tabular-nums; }
    #hud-x { right: 50%; border-top-right-radius: 0; border-bottom-right-radius: 0; text-align: right; }
    #hud-z { left: 50%; border-top-left-radius: 0; border-bottom-left-radius: 0; text-align: left; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 9999; }
    @font-face { font-family: 'MinecraftItalic'; src: url('/fonts/MinecraftItalic-R8Mo.otf') format('opentype'); }
  </style>
</head>
<body>
  <div id="loading">loading map...</div>
  <canvas id="main-canvas"></canvas>
  <span id="hud-x">0</span>
  <span id="hud-z">0</span>
  <div id="textbox" style="position:fixed;top:0;left:0;padding:6px;font:16px sans-serif;max-width:90vw;word-wrap:break-word;">
    TAB to show Labels
  </div>
  <div id="textbox2" hidden=true style="position:fixed;top:0;left:0;padding:6px;font:16px sans-serif;max-width:90vw;word-wrap:break-word;">
    THIS IS WORK IN PROGRESS AND NOT ACCURATE / COMPLETE!! (= please don't hate me)<br/>
    i just copied some of edii's labels as filler for now<br/>
    hopefully i can find someone to manage the data so i can focus on features and polish
  </div>
  <script>
    'use strict';

    // ========== CAMERA ==========
    class Camera {
      #x = 0;
      #y = 0;
      #scale = 1;
      #changeCallbacks = [];

      get x()     { return this.#x;     }
      get y()     { return this.#y;     }
      get scale() { return this.#scale; }

      set x(v)     { this.#x = v;     this.#changed(); }
      set y(v)     { this.#y = v;     this.#changed(); }
      set scale(v) { this.#scale = v; this.#changed(); }

      constructor() {
        Object.seal(this);
      }

      worldToScreen(x, y, screenWidth, screenHeight) {
        return {
          x: (x - this.#x) * this.#scale + screenWidth /2,
          y: (y - this.#y) * this.#scale + screenHeight/2,
        };
      }

      screenToWorld(x, y, screenWidth, screenHeight) {
        return {
          x: (x - screenWidth /2) / this.#scale + this.#x,
          y: (y - screenHeight/2) / this.#scale + this.#y,
        };
      }

      worldToScreenDistance(value) { return value * this.#scale; }
      screenToWorldDistance(value) { return value / this.#scale; }

      apply(ctx) {
        ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2)
        ctx.scale(this.#scale, this.#scale);
        ctx.translate(-this.#x, -this.#y);
      }

      addChangeCallback(changeCallback) {
        this.#changeCallbacks.push(changeCallback);
      }

      #changed() {
        this.#changeCallbacks.forEach(changeCallback => { changeCallback(); });
      }
    }

    class PanZoomController {
      #camera;
      #canvas;
      #pinchScaleHistory = []; // { scale, screenSpaceScaleFocus: { x, y }, time }
      #pressedPointerHistory = new Map(); // [{x, y, time, globalStateSnapshot}, ...]
      #globalPressedPointerStats = {
        pointerCount: 0,
        centerOfAllPointers: { x: 0, y: 0 },
        sumOfAllDistancesBetweenPointers: 0,
      };
      #panVelocity = { x: 0, y: 0 };
      #scaleVelocity = 0;
      #scaleVelocityIsFromPinch = false;
      #animatedScaleFocus = { x: 0, y: 0 };
      #previousFrameTimeStamp = null;
      #animationRequested = false;

      constructor(camera, canvas) {
        this.#camera = camera;
        this.#canvas = canvas;
        Object.seal(this);

        this.#canvas.addEventListener('pointerdown',   e => { this.#pointerDown(e);       });
        this.#canvas.addEventListener('pointermove',   e => { this.#pointerMove(e);       });
        this.#canvas.addEventListener('pointerup',     e => { this.#pointerUpOrCancel(e); });
        this.#canvas.addEventListener('pointercancel', e => { this.#pointerUpOrCancel(e); });
        this.#canvas.addEventListener('wheel',         e => { this.#wheel(e); });
      }

      #removePointerFromPressedPointerHistory(pointerId) {
        this.#pressedPointerHistory.delete(pointerId);
        this.#recalculatePressedPointerStats();
      }

      #recalculatePressedPointerStats() {
        const mostRecentPointerEvents = [...this.#pressedPointerHistory.values()].map(pointerHistory => pointerHistory[pointerHistory.length-1]);
        let distanceCount = 0;
        let sumOfAllDistancesBetweenPointers = 0;
        let sumOfAllPointerPositions = { x: 0, y: 0 };
        for (let i = 0; i < mostRecentPointerEvents.length; i++) {
          let ev1 = mostRecentPointerEvents[i];
          sumOfAllPointerPositions.x += ev1.x;
          sumOfAllPointerPositions.y += ev1.y;
          for (let j = i+1; j < mostRecentPointerEvents.length; j++) {
            let ev2 = mostRecentPointerEvents[j];
            sumOfAllDistancesBetweenPointers += Math.hypot(ev1.x - ev2.x, ev1.y - ev2.y);
            distanceCount += 1;
          }
        }
        this.#globalPressedPointerStats = {
          centerOfAllPointers: {
            x: sumOfAllPointerPositions.x / this.#pressedPointerHistory.size,
            y: sumOfAllPointerPositions.y / this.#pressedPointerHistory.size,
          },
          sumOfAllDistancesBetweenPointers,
          pointerCount: this.#pressedPointerHistory.size,
        };
      }

      #addEventToPressedPointerHistory(e) {
        // get history array (or create empty one)
        let history = this.#pressedPointerHistory.get(e.pointerId);
        if (history === undefined) {
          history = [];
          this.#pressedPointerHistory.set(e.pointerId, history);
        };

        // prune old events
        const cutoff = e.timeStamp - 20;
        while (history.length > 0 && history[0].time < cutoff) {
          history.shift();
        }

        let newEvent = {
          x: e.x,
          y: e.y,
          time: e.timeStamp,
        };
        history.push(newEvent);
        this.#recalculatePressedPointerStats();
        newEvent.globalStateSnapshot = this.#globalPressedPointerStats;
      }

      #appendPinchScaleHistory(scale, scaleFocusX, scaleFocusY, time) {
        this.#pinchScaleHistory.push({scale, screenSpaceScaleFocus: { x: scaleFocusX, y: scaleFocusY }, time});
        const cutoff = time - 50;
        while (this.#pinchScaleHistory.length > 0 && this.#pinchScaleHistory[0].time < cutoff) {
          this.#pinchScaleHistory.shift();
        }
      }

      #pointerDown(e) {
        // ignore right click
        if (e.pointerType === 'mouse' && e.button === 2) return;

        this.#addEventToPressedPointerHistory(e);
        this.#appendPinchScaleHistory(this.#camera.scale, e.x, e.y, e.timeStamp);
        this.#canvas.setPointerCapture(e.pointerId);
      }

      #pointerMove(e) {
        // pointer that moved is not pressed (mouse hover)
        if (!this.#pressedPointerHistory.has(e.pointerId)) return;

        const oldCenter = this.#globalPressedPointerStats.centerOfAllPointers;
        const oldDistance = this.#globalPressedPointerStats.sumOfAllDistancesBetweenPointers;

        this.#addEventToPressedPointerHistory(e);

        const newCenter = this.#globalPressedPointerStats.centerOfAllPointers;
        const newDistance = this.#globalPressedPointerStats.sumOfAllDistancesBetweenPointers;

        const oldWorldPos = this.#camera.screenToWorld(oldCenter.x, oldCenter.y, this.#canvas.width, this.#canvas.height);
        const pointerCount = this.#globalPressedPointerStats.pointerCount;
        this.#camera.scale *= (oldDistance === 0) ? 1 : Math.pow(newDistance/oldDistance, pointerCount-1);
        const newWorldPos = this.#camera.screenToWorld(newCenter.x, newCenter.y, this.#canvas.width, this.#canvas.height);
        this.#camera.x += oldWorldPos.x - newWorldPos.x;
        this.#camera.y += oldWorldPos.y - newWorldPos.y;

        this.#appendPinchScaleHistory(this.#camera.scale, newCenter.x, newCenter.y, e.timeStamp);

      }

      #calculatePanVelocity(e) {
        const history = this.#pressedPointerHistory.get(e.pointerId);

        // only look at the events with the maximum pointer count in the history
        // e.g. if there was a pinch, ignore the inevitable single pointer events at the end
        const maxPointerCount = Math.max(...history.map(ev => ev.globalStateSnapshot.pointerCount));
        const filteredHistory = history.filter(ev => ev.globalStateSnapshot.pointerCount === maxPointerCount);

        const firstEvent = filteredHistory[0];
        const lastEvent  = filteredHistory[filteredHistory.length - 1];

        const panDeltaTime = lastEvent.time - firstEvent.time;
        if (panDeltaTime === 0) {
          this.#panVelocity.x = 0;
          this.#panVelocity.y = 0;
        } else {
          this.#panVelocity.x = -this.#camera.screenToWorldDistance((lastEvent.globalStateSnapshot.centerOfAllPointers.x - firstEvent.globalStateSnapshot.centerOfAllPointers.x) / panDeltaTime);
          this.#panVelocity.y = -this.#camera.screenToWorldDistance((lastEvent.globalStateSnapshot.centerOfAllPointers.y - firstEvent.globalStateSnapshot.centerOfAllPointers.y) / panDeltaTime);
        }
      }

      #calculateScaleVelocity() {
        const firstScale = this.#pinchScaleHistory[0];
        const lastScale  = this.#pinchScaleHistory[this.#pinchScaleHistory.length - 1];

        const scaleDeltaTime = lastScale.time - firstScale.time;
        if (scaleDeltaTime === 0) {
          this.#scaleVelocity = 0;
        } else {
          this.#scaleVelocity = Math.log(lastScale.scale / firstScale.scale) / scaleDeltaTime;
          this.#scaleVelocityIsFromPinch = true;
        }
        this.#animatedScaleFocus = firstScale.screenSpaceScaleFocus;
      }

      #pointerUpOrCancel(e) {
        // ignore untracked pointer events
        if (this.#pressedPointerHistory.get(e.pointerId) === undefined) return;

        if (this.#pressedPointerHistory.size === 1) {
          // scale velocity
          this.#appendPinchScaleHistory(this.#camera.scale, e.x, e.y, e.timeStamp);
          this.#calculateScaleVelocity();

          if (this.#scaleVelocity === 0) {
            // pan velocity
            this.#addEventToPressedPointerHistory(e);
            this.#calculatePanVelocity(e);
          } else {
            this.#panVelocity.x = 0;
            this.#panVelocity.y = 0;
          }

          // fully released -> fling
          this.#requestAnimation();
        }
        this.#removePointerFromPressedPointerHistory(e.pointerId);
        this.#canvas.releasePointerCapture(e.pointerId);
      }

      #wheel(e) {
        e.preventDefault();
        if (e.deltaY === 0) return;

        let scaleFactor;
        if (e.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          scaleFactor = Math.pow(1.1, -e.deltaY/120);
        } else {
          scaleFactor = (e.deltaY > 0 ? 1/1.1 : 1.1);
        }

        const scaleVelocityChange = -e.deltaY/40000;
        if (Math.sign(this.#scaleVelocity) !== Math.sign(scaleVelocityChange)) {
          this.#scaleVelocity = 0;
        }
        this.#scaleVelocity += scaleVelocityChange;
        this.#scaleVelocityIsFromPinch = false;
        this.#animatedScaleFocus.x = e.x;
        this.#animatedScaleFocus.y = e.y;

        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;

        this.#requestAnimation();
      }

      #requestAnimation() {
        if (this.#animationRequested) return;
        window.requestAnimationFrame((t) => {
          this.#animationRequested = false;
          let dt = 16.6;
          if (this.#previousFrameTimeStamp !== null) {
            dt = Math.min(t - this.#previousFrameTimeStamp, 100);
          }
          this.#previousFrameTimeStamp = t;
          this.#animate(dt);
        });
        this.#animationRequested = true;
      }

      #animate(dt) {
        if (this.#pressedPointerHistory.size === 0) {

          this.#camera.x += this.#panVelocity.x * dt;
          this.#camera.y += this.#panVelocity.y * dt;
          this.#panVelocity.x *= .95;
          this.#panVelocity.y *= .95;

          const targetWorldPos = this.#camera.screenToWorld(this.#animatedScaleFocus.x, this.#animatedScaleFocus.y, this.#canvas.width, this.#canvas.height);
          this.#camera.scale *= Math.exp(this.#scaleVelocity * dt);
          const scaledWorldPos = this.#camera.screenToWorld(this.#animatedScaleFocus.x, this.#animatedScaleFocus.y, this.#canvas.width, this.#canvas.height);
          this.#camera.x += targetWorldPos.x - scaledWorldPos.x;
          this.#camera.y += targetWorldPos.y - scaledWorldPos.y;
          if (this.#scaleVelocityIsFromPinch) {
            this.#scaleVelocity *= .9;
          } else {
            this.#scaleVelocity *= .8;
          }

          if (Math.abs(this.#scaleVelocity) > .0001 || this.#camera.worldToScreenDistance(Math.hypot(this.#panVelocity.x, this.#panVelocity.y)) > .01) {
            this.#requestAnimation();
            return;
          }
        }
        this.#previousFrameTimeStamp = null;
        this.#panVelocity.x = 0;
        this.#panVelocity.y = 0;
        this.#scaleVelocity = 0;
      }
    }



    // ========== LABELS ==========

    class Label {
      #text;
      #position;
      #fillStyle;
      #strokeStyle;
      #lineWidth;
      constructor(text, worldX, worldY, fillStyle, strokeStyle = '#000', lineWidth = 10.) {
        this.#text = text;
        this.#position = { x: 0, y: 0 };
        this.#position.x = worldX;
        this.#position.y = worldY;
        this.#fillStyle = fillStyle;
        this.#strokeStyle = strokeStyle;
        this.#lineWidth = lineWidth;
        Object.seal(this);
      }

      draw(ctx, camera) {
        let screenPos = camera.worldToScreen(this.#position.x, this.#position.y, ctx.canvas.width, ctx.canvas.height);

        let textScale = camera.scale < .5 ? camera.scale: .5;

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `${100 * textScale}px MinecraftItalic`;

        ctx.strokeStyle = this.#strokeStyle;
        ctx.lineWidth = this.#lineWidth*2 * textScale;
        ctx.strokeText(this.#text, screenPos.x, screenPos.y);

        ctx.fillStyle = this.#fillStyle;
        ctx.fillText(this.#text, screenPos.x, screenPos.y);
      }
    }



    // ========== GLOBALS ==========
    const mainCanvas = document.getElementById('main-canvas');
    const hudX = document.getElementById('hud-x');
    const hudZ = document.getElementById('hud-z');

    const mainCanvasContext = mainCanvas.getContext('2d');
    const mainCamera = new Camera();
    const cameraPanZoomController = new PanZoomController(mainCamera, mainCanvas);

    let worldBitmap = null;
    let worldOffsetX = 0;
    let worldOffsetY = 0;

    let animationFrameRequested = false;

    let clickedWorldCoords = null;

    let showMapLabels = false;
    let mapLabels = [
      new Label('Renkai', 2244, -767, '#f300f3'),
      new Label('Sarkovia', 943, -265, '#f90120'),
      new Label('Imperium', 2656, 98, '#de8644'),
      new Label('Checkerboard Union', 1421, 1124, '#b9bbcc'),
      new Label('The SWZT', -46, 1487, '#559b16'),
      new Label('The Holy Hydra Empire', -1219, 445, '#f38912'),
      new Label('Helioria', -1427, -960, '#bbdc65'),
      new Label('Polestar', 1653, -273, '#6767ea'),
      new Label('Cooked v2', -123, -389, '#01fefe'),
      new Label('El Gran Cartel', -2416, 507, '#32ed22'),
      new Label('Northelios', 2517, -1470, '#fe3333'),
      new Label('Pantha', -123, -1346, '#43a6d9'),
      new Label('Soup Bowl', -2910, -543, '#d1502f'),
      new Label('Penguinia', 1583, -1323, '#8667de'),
      new Label('Harvestspire', 3050, 1271, '#56935b'),
    ];

    document.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        e.preventDefault();
        let textbox = document.getElementById('textbox').hidden = true;
        let textbox2 = document.getElementById('textbox2');
        if (!textbox2.hidden) {
          textbox2.textContent = 'WIP!!';
        }
        textbox2.hidden = !textbox2.hidden;
        showMapLabels = !showMapLabels;
        requestRender();
      }
    });



    // ========== COORDS  ==========
    mainCanvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      let newClickedWorldCoords = mainCamera.screenToWorld(e.x, e.y, mainCanvas.width, mainCanvas.height);
      newClickedWorldCoords.x = Math.floor(newClickedWorldCoords.x);
      newClickedWorldCoords.y = Math.floor(newClickedWorldCoords.y);
      if (clickedWorldCoords != null && newClickedWorldCoords.x === clickedWorldCoords.x && newClickedWorldCoords.y === clickedWorldCoords.y) {
        clickedWorldCoords = null;
        window.history.replaceState({}, '', `${window.location.pathname}`);
        hudX.style.display = 'none';
        hudZ.style.display = 'none';
      } else {
        clickedWorldCoords = newClickedWorldCoords;
        window.history.replaceState({}, '', `${window.location.pathname}?${clickedWorldCoords.x},${clickedWorldCoords.y}`);
        hudX.textContent = clickedWorldCoords.x;
        hudZ.textContent = clickedWorldCoords.y;
        hudX.style.display = 'block';
        hudZ.style.display = 'block';
      }
      requestRender();
    });



    // ========== RENDER ==========
    mainCamera.addChangeCallback(() => { requestRender(); })

    function requestRender() {
      if (animationFrameRequested) return;
      window.requestAnimationFrame((t) => {
        animationFrameRequested = false;
        render(mainCanvasContext, mainCamera);
      });
      animationFrameRequested = true;
    }

    function render(ctx, camera) {
      if (worldBitmap === null) return;

      ctx.resetTransform();
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.imageSmoothingEnabled = camera.scale < 1;

      camera.apply(ctx);

      if (worldBitmap !== null) {
        ctx.drawImage(worldBitmap, worldOffsetX, worldOffsetY);
      }

      ctx.resetTransform();

      if (showMapLabels) {
        ctx.fillStyle = '#0005';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        for (const label of mapLabels) {
          label.draw(ctx, camera);
        }
      }

      if (clickedWorldCoords !== null) {
        let screenCoords = camera.worldToScreen(clickedWorldCoords.x + .5, clickedWorldCoords.y + .5, mainCanvas.width, mainCanvas.height);
        drawPin(ctx, screenCoords.x, screenCoords.y);
      }

    }

    function drawPin(ctx, x, y, color = '#F00') {
      const pinWidth = 24;
      const pinHeight = 20;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - pinWidth/2, y - pinHeight);
      ctx.lineTo(x + pinWidth/2, y - pinHeight);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }



    // ========== EVENTS ==========
    window.addEventListener('resize', () => {
      mainCanvas.width = window.innerWidth;
      mainCanvas.height = window.innerHeight;
      requestRender();
    });

    (async () => {
      window.dispatchEvent(new Event('resize'));
      await document.fonts.load('32px MinecraftItalic');
      const res = await fetch('/mapdata/usgsmap_day6_contributions_v2.png');
      const blob = await res.blob();
      worldBitmap = await createImageBitmap(blob);
      let scaleX = mainCanvas.width / (worldBitmap.width * 1.1);
      let scaleY = mainCanvas.height / (worldBitmap.height * 1.1);
      mainCamera.scale = Math.min(scaleX, scaleY);
      mainCamera.x = 0;
      mainCamera.y = 0;
      worldOffsetX = 3453 - 7578;
      worldOffsetY = 1213 - 3746;
      document.getElementById('loading').remove();
      let urlCoords = window.location.search.slice(1).split(',').map(Number);
      if (urlCoords.length == 2 && !Number.isNaN(urlCoords[0]) && !Number.isNaN(urlCoords[1])) {
        clickedWorldCoords = { x: Math.floor(urlCoords[0]), y: Math.floor(urlCoords[1]) };
        window.history.replaceState({}, '', `${window.location.pathname}?${clickedWorldCoords.x},${clickedWorldCoords.y}`);
        hudX.textContent = clickedWorldCoords.x;
        hudZ.textContent = clickedWorldCoords.y;
        hudX.style.display = 'block';
        hudZ.style.display = 'block';
      } else {
        window.history.replaceState({}, '', `${window.location.pathname}`);
      }
      window.setTimeout(() => { document.getElementById('textbox').hidden = true; }, 5000);
      requestRender();
    })();
  </script>
</body>
</html>
